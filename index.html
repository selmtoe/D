<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç™„É≥„É©„Ç§„É≥Â§ßÂØåË±™ v5 (‰øÆÊ≠£Áâà)</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #004d40; /* Ê∑±„ÅÑÁ∑ë */
            color: #E0E0E0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            /* overflow: hidden; „ÇíÂâäÈô§„Åó„Å¶„Çπ„ÇØ„É≠„Éº„É´„ÇíÊúâÂäπÂåñ */
        }

        .screen { display: none; }
        .active { display: block; }

        /* Login and Room screens use a light container */
        .container {
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
            width: 100%;
            max-width: 800px;
            text-align: center;
        }
        
        /* Game screen uses the dark theme directly */
        #game-screen.container {
            max-width: 1200px;
            background-color: transparent;
            color: #E0E0E0;
            box-shadow: none;
        }

        h1, h2 {
            color: #004d40;
        }
        
        #game-screen h1, #game-screen h2, #game-screen h3 {
             color: #e0f2f1;
        }

        input[type="text"] {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }

        button {
            background-color: #00796b; /* „ÉÜ„Ç£„Éº„É´„Ç∞„É™„Éº„É≥ */
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #004d40; }
        button:disabled {
            background-color: #999;
            color: #e0e0e0;
            cursor: not-allowed;
        }

        .game-info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 5px;
        }

        .game-status-icons {
            font-size: 32px;
            display: flex;
            gap: 15px;
        }
        
        .players-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap; /* „Éó„É¨„Ç§„É§„Éº„ÅåÂ¢ó„Åà„Å¶„ÇÇÊîπË°å„Åï„Çå„Çã„Çà„ÅÜ„Å´ */
            gap: 10px;
            margin-bottom: 20px;
            min-height: 120px;
        }

        .player-box {
            border: 2px solid #00796b;
            border-radius: 8px;
            padding: 10px;
            width: 150px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        .player-box.is-turn {
            border-color: #80cbc4; /* Êòé„Çã„ÅÑ„ÉÜ„Ç£„Éº„É´ */
            box-shadow: 0 0 15px #80cbc4;
            font-weight: bold;
            transform: scale(1.05);
        }
        .player-box.finished {
            opacity: 0.5;
            border-style: dashed;
        }
        .other-player-cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2px;
            margin-top: 5px;
        }
        .card-back {
            width: 12px;
            height: 18px;
            background-color: #666;
            border: 1px solid white;
            border-radius: 2px;
        }

        .field {
            border: 2px dashed #00796b;
            min-height: 150px;
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            background-color: rgba(0,0,0,0.1);
        }

        .my-hand-container {
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
        }

        .card-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }

        .card {
            border: 1px solid #999;
            border-radius: 5px;
            width: 70px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            background-color: white;
            cursor: pointer;
            user-select: none;
            position: relative;
            padding: 5px;
            box-sizing: border-box;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            color: #333;
            transition: all 0.2s;
        }
        .card.selected {
            transform: translateY(-10px);
            box-shadow: 0 6px 10px #00796b;
            border-color: #00796b;
        }
        .card.red { color: red; }
        .card.joker { background-color: #f0f0f0; }
        .card.is-transformed .card-number {
             color: #00796b;
             font-style: italic;
        }
        .card.is-transformed .suit {
            opacity: 0.6;
        }
        .card .suit { font-size: 1em; }
        .card .card-number { font-size: 1.2em; }


        #room-info-container {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #a0a0a0;
        }
        #copy-room-id-button {
            padding: 5px 10px;
            font-size: 14px;
            min-width: 80px;
        }
        
        /* Modal Styles */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #modal-overlay.hidden { display: none; }
        #modal-container {
            background-color: #fff;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            text-align: center;
        }
        #modal-body {
            max-height: 60vh;
            overflow-y: auto;
            margin: 20px 0;
        }
        .modal-card-selection .card { margin: 5px; }
        .modal-player-selection button, .modal-rank-selection button {
             width: 100px;
             margin: 5px;
        }
        .modal-joker-transform button {
            background-color: #f0f0f0;
            color: #333;
        }
        .modal-joker-transform button.selected {
            background-color: #004d40;
            color: white;
        }
        .modal-rank-selection button.selected {
            background-color: #004d40;
        }

        #results-table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
        }
        #results-table th, #results-table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        #results-table th {
            background-color: #f2f2f2;
        }


        /* Cut-in Effect */
        #cutin-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }
        #cutin-overlay.visible { opacity: 1; }
        #cutin-box {
            background: rgba(255, 255, 255, 0.9);
            color: #004d40;
            padding: 30px 60px;
            border-radius: 10px;
            text-align: center;
            transform: scale(0.5);
            transition: transform 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        #cutin-overlay.visible #cutin-box { transform: scale(1); }
        #cutin-card-name {
            font-size: 3em;
            font-weight: bold;
            display: block;
        }
        #cutin-effect-name {
            font-size: 2em;
        }

        /* Log Panel */
        #log-panel {
            position: fixed;
            left: -350px;
            top: 0;
            bottom: 0;
            width: 320px;
            background-color: rgba(0, 0, 0, 0.8);
            border-right: 2px solid #00796b;
            display: flex;
            flex-direction: column;
            transition: left 0.3s ease-in-out;
            z-index: 900;
        }
        #log-panel.visible { left: 0; }
        #log-header {
            padding: 10px;
            border-bottom: 1px solid #00796b;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #log-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 14px;
        }
        #log-messages p { margin: 5px 0; }
        #show-log-button {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 901;
        }

    </style>
    <link rel="manifest" href="manifest.json">
</head>
<body>

    <div id="login-screen" class="container screen active">
        <h1>„Ç™„É≥„É©„Ç§„É≥Â§ßÂØåË±™</h1>
        <input type="text" id="name-input" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ">
        <button id="login-button">Ê±∫ÂÆö</button>
    </div>

    <div id="room-screen" class="container screen">
        <h1>„É´„Éº„É†ÈÅ∏Êäû</h1>
        <p>„Çà„ÅÜ„Åì„Åù„ÄÅ<span id="player-name-display"></span>„Åï„Çì</p>
        <button id="create-room-button">„É´„Éº„É†„Çí‰ΩúÊàê„Åô„Çã</button>
        <hr style="margin: 20px 0;">
        <input type="text" id="room-id-input" placeholder="„É´„Éº„É†ID„ÇíÂÖ•Âäõ">
        <button id="join-room-button">„É´„Éº„É†„Å´ÂèÇÂä†„Åô„Çã</button>
    </div>

    <div id="game-screen" class="container screen">
        <div class="game-info-bar">
            <div>
                <h2>Â§ßÂØåË±™</h2>
                <span id="turn-info"></span>
            </div>
            <div class="game-status-icons">
                 <span id="revolution-icon" title="Èù©ÂëΩ‰∏≠" style="display:none;">‚öîÔ∏è</span>
                 <span id="j-back-icon" title="J„Éê„ÉÉ„ÇØ‰∏≠" style="display:none;">J</span>
                 <span id="reverse-icon" title="„É™„Éê„Éº„Çπ‰∏≠" style="display:none;">üîÑ</span>
            </div>
        </div>
        
        <div id="players-container" class="players-container"></div>
        
        <h3>Â†¥ (<span id="last-player-info"></span>)</h3>
        <div id="field" class="field"></div>
        
        <div class="my-hand-container">
             <h3>„ÅÇ„Å™„Åü„ÅÆÊâãÊú≠ (<span id="my-name"></span>)</h3>
             <div id="my-hand" class="card-container"></div>
        </div>

        <div id="controls" class="controls">
            <button id="play-button" disabled>Âá∫„Åô</button>
            <button id="pass-button" disabled>„Éë„Çπ</button>
        </div>
        
        <div id="game-controls">
             <button id="start-game-button" style="display: none; background-color: #28a745;">„Ç≤„Éº„É†ÈñãÂßã</button>
        </div>

        <div id="room-info-container">
            <span id="room-info"></span>
            <button id="copy-room-id-button" style="display: none;">ID„Ç≥„Éî„Éº</button>
        </div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-container">
            <h2 id="modal-title"></h2>
            <div id="modal-body"></div>
            <div id="modal-actions">
                <button id="modal-confirm-button">Ê±∫ÂÆö</button>
                <button id="modal-cancel-button">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
        </div>
    </div>
    
    <div id="cutin-overlay" class="hidden">
        <div id="cutin-box">
            <span id="cutin-card-name"></span>
            <span id="cutin-effect-name"></span>
        </div>
    </div>

    <div id="log-panel">
        <div id="log-header">
            <h3>„Ç≤„Éº„É†„É≠„Ç∞</h3>
            <button id="log-close-button">√ó</button>
        </div>
        <div id="log-messages"></div>
    </div>
    <button id="show-log-button">„É≠„Ç∞Ë°®Á§∫</button>

    <script type="module">
        // ‚ñº‚ñº‚ñº „Åì„Åì„Å´Firebase„ÅÆË®≠ÂÆö„ÇíË≤º„Çä‰ªò„Åë ‚ñº‚ñº‚ñº
        const firebaseConfig = {
            apiKey: "AIzaSyD1YdTMESZi-ynMzS_p_hdtr1znBI64RmM",
            authDomain: "daifugo-8e039.firebaseapp.com",
            projectId: "daifugo-8e039",
            storageBucket: "daifugo-8e039.firebasestorage.app",
            messagingSenderId: "979025215319",
            appId: "1:979025215319:web:1bf381daf1eb647760c812",
            measurementId: "G-KSQ8LRN4ZE"
        };
        // ‚ñ≤‚ñ≤‚ñ≤ „Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        const showAlert = (message) => { alert(message); };
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Global variables
        let currentPlayer = { id: null, name: null };
        let currentRoomId = null;
        let unsubscribeRoom = null;
        let selectedCards = []; // Stores { suit, number, uid, mimics?: {suit, number} }
        let cardUidsInHand = new Set();
        let currentModal = { resolve: null, reject: null };
        let lastKnownLogCount = 0;

        // DOM Elements
        const screens = { login: document.getElementById('login-screen'), room: document.getElementById('room-screen'), game: document.getElementById('game-screen') };
        const nameInput = document.getElementById('name-input');
        const loginButton = document.getElementById('login-button');
        const playerNameDisplay = document.getElementById('player-name-display');
        const createRoomButton = document.getElementById('create-room-button');
        const joinRoomButton = document.getElementById('join-room-button');
        const roomIdInput = document.getElementById('room-id-input');
        const myHandDiv = document.getElementById('my-hand');
        const playersContainerDiv = document.getElementById('players-container');
        const fieldDiv = document.getElementById('field');
        const turnInfoSpan = document.getElementById('turn-info');
        const lastPlayerInfoSpan = document.getElementById('last-player-info');
        const roomInfoSpan = document.getElementById('room-info');
        const copyRoomIdButton = document.getElementById('copy-room-id-button');
        const startGameButton = document.getElementById('start-game-button');
        const playButton = document.getElementById('play-button');
        const passButton = document.getElementById('pass-button');
        const myNameSpan = document.getElementById('my-name');
        const revolutionIcon = document.getElementById('revolution-icon');
        const jBackIcon = document.getElementById('j-back-icon');
        const reverseIcon = document.getElementById('reverse-icon');
        // Modal DOM Elements
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalConfirmButton = document.getElementById('modal-confirm-button');
        const modalCancelButton = document.getElementById('modal-cancel-button');
        // Cut-in & Log DOM Elements
        const cutinOverlay = document.getElementById('cutin-overlay');
        const cutinCardName = document.getElementById('cutin-card-name');
        const cutinEffectName = document.getElementById('cutin-effect-name');
        const logPanel = document.getElementById('log-panel');
        const showLogButton = document.getElementById('show-log-button');
        const logCloseButton = document.getElementById('log-close-button');
        const logMessagesDiv = document.getElementById('log-messages');


        // --- Screen Navigation ---
        function showScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            screens[screenName].classList.add('active');
        }

        // --- Login ---
        loginButton.addEventListener('click', () => {
            const name = nameInput.value.trim();
            if (name) {
                currentPlayer.name = name;
                currentPlayer.id = generatePlayerId();
                playerNameDisplay.textContent = name;
                showScreen('room');
            } else { showAlert('ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'); }
        });
        
        // --- Room Creation/Joining ---
        createRoomButton.addEventListener('click', async () => {
            currentRoomId = generateRoomId();
            const roomRef = doc(db, 'rooms', currentRoomId);
            const newPlayer = { id: currentPlayer.id, name: currentPlayer.name, isHost: true, hand: [], order: -1, rank: null };
            await setDoc(roomRef, {
                id: currentRoomId,
                players: [newPlayer],
                gameState: 'waiting', // waiting, playing, finished
                field: [], discardPile: [],
                lastPlayed: { player: null, cards: [] },
                turnPlayerId: null, passCount: 0,
                isRevolution: false, isJBackActive: false,
                turnDirection: 1, // 1 for normal, -1 for reverse
                createdAt: serverTimestamp(),
                pendingActions: [],
                log: [{ timestamp: Date.now(), message: `„É´„Éº„É†„Åå‰ΩúÊàê„Åï„Çå„Åæ„Åó„Åü„ÄÇ` }]
            });
            joinRoom(currentRoomId);
        });

joinRoomButton.addEventListener('click', async () => {
            const roomId = roomIdInput.value.trim();
            if (!roomId) return showAlert('„É´„Éº„É†ID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            const roomRef = doc(db, 'rooms', roomId);
            const roomSnap = await getDoc(roomRef);

            if (!roomSnap.exists()) return showAlert('ÊåáÂÆö„Åï„Çå„Åü„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ');
            const roomData = roomSnap.data();
            if (roomData.players.find(p => p.name === currentPlayer.name)) return showAlert('Âêå„ÅòÂêçÂâç„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅåÊó¢„Å´„É´„Éº„É†„Å´„ÅÑ„Åæ„Åô„ÄÇ');
            if (roomData.players.length >= 6) return showAlert('„Åì„ÅÆ„É´„Éº„É†„ÅØÊ∫ÄÂì°„Åß„Åô„ÄÇ');
            if (roomData.gameState === 'playing') return showAlert('„Åì„ÅÆ„Ç≤„Éº„É†„ÅØÊó¢„Å´ÈñãÂßã„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ');

            const newPlayer = { id: currentPlayer.id, name: currentPlayer.name, isHost: false, hand: [], order: -1, rank: null };
            await updateDoc(roomRef, { 
                players: arrayUnion(newPlayer),
                log: arrayUnion({ timestamp: Date.now(), message: `${currentPlayer.name}„Åï„Çì„ÅåÂèÇÂä†„Åó„Åæ„Åó„Åü„ÄÇ` })
            });
            joinRoom(roomId);
        });

        function joinRoom(roomId) {
            currentRoomId = roomId;
            myNameSpan.textContent = currentPlayer.name;
            showScreen('game');
            if (unsubscribeRoom) unsubscribeRoom();
            unsubscribeRoom = onSnapshot(doc(db, 'rooms', currentRoomId), (doc) => {
                if (doc.exists()) {
                    const roomData = doc.data();
                    renderGame(roomData);
                    if(roomData.gameState !== 'finished') {
                       handlePendingAction(roomData);
                    }
                } else { 
                    showAlert('„É´„Éº„É†„ÅåÂâäÈô§„Åï„Çå„Åæ„Åó„Åü„ÄÇ'); 
                    location.reload(); 
                }
            });
        }
        
        copyRoomIdButton.addEventListener('click', () => {
            navigator.clipboard.writeText(currentRoomId).then(() => {
                copyRoomIdButton.textContent = '„Ç≥„Éî„ÉºÂÆå‰∫Ü!';
                setTimeout(() => { copyRoomIdButton.textContent = 'ID„Ç≥„Éî„Éº'; }, 1500);
            });
        });

        // --- Game Start ---
        startGameButton.addEventListener('click', async () => {
            const roomRef = doc(db, 'rooms', currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room not found.");
                    const roomData = roomSnap.data();

                    if (roomData.players.length < 3) throw new Error('3‰∫∫‰ª•‰∏ä„Åß„Ç≤„Éº„É†„ÇíÈñãÂßã„Åß„Åç„Åæ„Åô„ÄÇ');

                    const suits = ['spade', 'heart', 'diamond', 'club'];
                    let deck = [];
                    suits.forEach(s => { for (let i = 1; i <= 13; i++) deck.push({ suit: s, number: i, uid: `${s}-${i}` }); });
                    deck.push({ suit: 'joker', number: 15, uid: 'joker-1' });
                    deck.push({ suit: 'joker', number: 15, uid: 'joker-2' });
                    deck = deck.sort(() => Math.random() - 0.5);

                    let players = [...roomData.players].sort(() => Math.random() - 0.5);
                    let dia3PlayerId = null;
                    players.forEach(p => { p.hand = []; p.rank = null; });
                    let pIndex = 0;
                    while (deck.length > 0) {
                        const card = deck.pop();
                        players[pIndex].hand.push(card);
                        if (card.suit === 'diamond' && card.number === 3) dia3PlayerId = players[pIndex].id;
                        pIndex = (pIndex + 1) % players.length;
                    }
                    
                    const firstPlayerId = dia3PlayerId || players[0].id;
                    const firstPlayerIndex = players.findIndex(p => p.id === firstPlayerId);
                    const sortedPlayers = [];
                    for (let i = 0; i < players.length; i++) {
                        const p = players[(firstPlayerIndex + i) % players.length];
                        p.order = i + 1;
                        sortedPlayers.push(p);
                    }
                    
                    sortedPlayers.forEach(p => p.hand.sort((a, b) => getCardStrength(a) - getCardStrength(b)));
                    
                    transaction.update(roomRef, {
                        players: sortedPlayers, gameState: 'playing',
                        turnPlayerId: firstPlayerId, field: [],
                        discardPile: [], passCount: 0,
                        lastPlayed: { player: null, cards: [] },
                        isRevolution: false, isJBackActive: false, turnDirection: 1,
                        pendingActions: [],
                        log: arrayUnion({ timestamp: Date.now(), message: `„Ç≤„Éº„É†„ÅåÈñãÂßã„Åï„Çå„Åæ„Åó„Åü„ÄÇÊúÄÂàù„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅØ${sortedPlayers.find(p=>p.id===firstPlayerId).name}„Åï„Çì„Åß„Åô„ÄÇ` })
                    });
                });
            } catch (error) { showAlert(error.message); }
        });

        // --- Game Actions ---
        playButton.addEventListener('click', async () => {
            if (selectedCards.length === 0) return;
            const roomRef = doc(db, 'rooms', currentRoomId);

            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room does not exist.");
                    const roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    const validation = isValidPlay(selectedCards, me.hand, roomData);
                    if (!validation.valid) throw new Error(validation.message);

                    const playedCardUids = new Set(selectedCards.map(c => c.uid));
                    const newHand = me.hand.filter(c => !playedCardUids.has(c.uid));
                    let playersCopy = roomData.players.map(p => p.id === me.id ? { ...p, hand: newHand } : p);

                    const cleanedPlayedCards = selectedCards.map(c => ({ suit: c.suit, number: c.number, uid: c.uid }));
                    
                    let logEntries = [{ timestamp: Date.now(), message: `${me.name}„Åå${cardsToString(selectedCards)}„ÇíÂá∫„Åó„Åæ„Åó„Åü„ÄÇ` }];

                    let nextState = {
                        players: playersCopy, field: cleanedPlayedCards, passCount: 0,
                        lastPlayed: { player: me.id, cards: cleanedPlayedCards },
                        isRevolution: roomData.isRevolution, isJBackActive: roomData.isJBackActive,
                        turnDirection: roomData.turnDirection, turnPlayerId: roomData.turnPlayerId,
                        discardPile: [...roomData.discardPile, ...roomData.field.map(c => cleanCard(c))],
                        pendingActions: []
                    };
                    
                    let clearField = false, skipCount = 0;
                    const isPlayStair = isStair(selectedCards);

                    if (isPlayStair) {
                        logEntries.push({ timestamp: Date.now(), message: "ÈöéÊÆµ„Åß„ÅôÔºÅÂäπÊûú„ÇíÈ†ÜÊ¨°Âá¶ÁêÜ„Åó„Åæ„Åô„ÄÇ" });
                        let effectsToProcess = selectedCards.map(c => (c.mimics ? c.mimics : c).number);
                        
                        if (effectsToProcess.includes(11)) { // J„Éê„ÉÉ„ÇØ
                            nextState.isJBackActive = !nextState.isJBackActive;
                            logEntries.push({ timestamp: Date.now(), message: `ÈöéÊÆµÂäπÊûú: J„Éê„ÉÉ„ÇØÁô∫ÂãïÔºÅ`, effect: {card:"J", name: "J„Éê„ÉÉ„ÇØ"}});
                            effectsToProcess = effectsToProcess.filter(n => n !== 11);
                        }
                        
                        if (selectedCards.length >= 4) {
                            nextState.isRevolution = !nextState.isRevolution;
                            logEntries.push({timestamp: Date.now(), message: `ÈöéÊÆµÂäπÊûú: Èù©ÂëΩÁô∫ÁîüÔºÅÂº∑„Åï„Åå${nextState.isRevolution ? 'ÈÄÜËª¢' : 'Ê≠£Â∏∏„Å´'}„Å™„Çä„Åæ„Åó„Åü„ÄÇ`});
                        }

                        const strengthReversed = nextState.isRevolution ^ nextState.isJBackActive;
                        effectsToProcess.sort((a, b) => {
                            const valA = getCardValue({number: a}, nextState);
                            const valB = getCardValue({number: b}, nextState);
                            return valA - valB;
                        });

                        if (effectsToProcess.includes(13)) { // KÂõûÂèé
                           effectsToProcess = effectsToProcess.filter(n => n !== 13);
                           effectsToProcess.unshift(13);
                        }
                        
                        const actionTypeMap = { 1:'steal_select_player', 7:'pass_select_player', 10:'discard_select_cards', 12:'bomber_select_rank', 13:'collect_select_cards' };
                        effectsToProcess.forEach(num => {
                             const effectMap = {1:"AÂ•™„ÅÑ",4:"„É™„Éê„Éº„Çπ", 5:"5„Çπ„Ç≠„ÉÉ„Éó", 7:"7Ê∏°„Åó", 8:"8Âàá„Çä", 10:"10Êç®„Å¶", 12:"Q„Éú„É≥„Éê„Éº", 13:"KÂõûÂèé"};
                             if(effectMap[num]) {
                                 logEntries.push({ timestamp: Date.now(), message: `ÈöéÊÆµÂäπÊûú: ${numberToString(num)} - ${effectMap[num]}`, effect: {card:numberToString(num), name: effectMap[num]}});
                             }
                            switch(num) {
                                case 4: nextState.turnDirection *= -1; break;
                                case 5: skipCount++; break;
                                case 8: clearField = true; break;
                                case 7: case 10: case 12: case 13: case 1:
                                    nextState.pendingActions.push({ type: actionTypeMap[num], actorId: me.id, count: 1 });
                                    break;
                            }
                        });
                        
                    } else {
                        const realCards = selectedCards.map(c => c.mimics ? c.mimics : c).filter(c => c.suit !== 'joker');
                        const playedNumber = realCards.length > 0 ? realCards[0].number : null;
                        
                        if (selectedCards.length === 2 && selectedCards.every(c => c.suit === 'joker' && !c.mimics)) {
                            clearField = true;
                            logEntries.push({timestamp: Date.now(), message: "ÊúÄÂº∑„ÅÆJoker„Éö„Ç¢ÔºÅÂ†¥„ÅåÊµÅ„Çå„Åæ„Åô„ÄÇ"});
                        }
                        if (selectedCards.length >= 4) {
                            nextState.isRevolution = !nextState.isRevolution;
                            logEntries.push({timestamp: Date.now(), message: `Èù©ÂëΩÁô∫ÁîüÔºÅÂº∑„Åï„Åå${nextState.isRevolution ? 'ÈÄÜËª¢' : 'Ê≠£Â∏∏„Å´'}„Å™„Çä„Åæ„Åó„Åü„ÄÇ`});
                        }
                        
                        if (playedNumber) {
                            const effectMap = {1:"AÂ•™„ÅÑ",/*3:"„Çπ„Éö3Ëøî„Åó",*/ 5:"5„Çπ„Ç≠„ÉÉ„Éó", 7:"7Ê∏°„Åó", 8:"8Âàá„Çä", 10:"10Êç®„Å¶", 11:"J„Éê„ÉÉ„ÇØ", 12:"Q„Éú„É≥„Éê„Éº", 13:"KÂõûÂèé"};
                            const effectName = effectMap[playedNumber];
                            if(effectName) logEntries.push({ timestamp: Date.now(), message: `ÂäπÊûúÁô∫Âãï: ${numberToString(playedNumber)} - ${effectName}`, effect: {card:numberToString(playedNumber), name: effectName}});
                            switch(playedNumber) {
                                case 4: 
                                    if (selectedCards.length % 2 !== 0) {
                                        nextState.turnDirection *= -1;
                                        logEntries.push({ timestamp: Date.now(), message: `ÂäπÊûúÁô∫Âãï: 4 - „É™„Éê„Éº„Çπ`, effect: {card:"4", name: "„É™„Éê„Éº„Çπ"}});
                                    }
                                    break;
                                case 5:
                                    const activePlayersCount = roomData.players.filter(p => p.rank === null).length;
                                    if (activePlayersCount <= 1) break;
                                    const skipAmount = (2 * selectedCards.length) - 1;
                                    const totalMoves = 1 + skipAmount;
                                    if (activePlayersCount > 1 && totalMoves % activePlayersCount === 0) {
                                        clearField = true;
                                        logEntries.push({timestamp: Date.now(), message: "5„Çπ„Ç≠„ÉÉ„Éó„ÅÆÂäπÊûú„ÅßÂ†¥„ÅåÊµÅ„Çå„Åæ„Åó„ÅüÔºÅ"});
                                    } else {
                                        skipCount = skipAmount;
                                    }
                                    break;
                                case 6: case 9: 
                                    if (selectedCards.length >= 2) {
                                        clearField = true;
                                        const specificEffectName = playedNumber === 6 ? "„Çç„Åè„ÇçÈ¶ñ" : "ÊïëÊÄ•Ëªä";
                                        logEntries.push({ timestamp: Date.now(), message: `ÂäπÊûúÁô∫Âãï: ${numberToString(playedNumber)} - ${specificEffectName}`, effect: {card:numberToString(playedNumber), name: specificEffectName}});
                                    }
                                    break;
                                case 8: 
                                    clearField = true;
                                    logEntries.push({ timestamp: Date.now(), message: `ÂäπÊûúÁô∫Âãï: 8 - 8Âàá„Çä`, effect: {card:"8", name: "8Âàá„Çä"}});
                                    break;
                                case 11: nextState.isJBackActive = !nextState.isJBackActive; break;
                                case 3: 
                                    if (selectedCards.length === 1 && selectedCards[0].suit === 'spade' && roomData.field.length === 1 && roomData.field[0].suit === 'joker' && !roomData.field[0].mimics) {
                                         clearField = true;
                                         logEntries.push({ timestamp: Date.now(), message: `ÂäπÊûúÁô∫Âãï: „Çπ„Éö„Éº„Éâ3Ëøî„ÅóÔºÅ`, effect: {card:"„Çπ„Éö„Éº„Éâ3", name: "„Çπ„Éö3Ëøî„Åó"}});
                                    }
                                    break;
                                case 7: case 10: case 12: case 13: case 1:
                                    const actionTypeMap = { 1:'steal_select_player', 7:'pass_select_player', 10:'discard_select_cards', 12:'bomber_select_rank', 13:'collect_select_cards' };
                                    nextState.pendingActions.push({ type: actionTypeMap[playedNumber], actorId: me.id, count: selectedCards.length });
                                    break;
                            }
                        }
                    }

                    if (newHand.length === 0 && nextState.pendingActions.length === 0) {
                        const { updatedPlayers,‰∏ä„Åå„ÇäLog } = handlePlayerFinish(nextState.players, me.id);
                        nextState.players = updatedPlayers;
                        logEntries.push(...‰∏ä„Åå„ÇäLog);
                    }
                    
                    const remainingPlayers = nextState.players.filter(p => p.rank === null).length;

                    if (nextState.pendingActions.length > 0) {
                        nextState.turnPlayerId = me.id;
                    } else if (clearField || remainingPlayers <= 1) {
                        nextState.discardPile = [...nextState.discardPile, ...nextState.field];
                        nextState.field = [];
                        nextState.passCount = 0;
                        nextState.turnPlayerId = me.id; 
                        nextState.isJBackActive = false; 
                    } else {
                        nextState.turnPlayerId = getNextPlayerId(nextState.players, me.id, nextState.turnDirection, skipCount);
                    }
                    
                    const finalState = checkGameEnd(nextState);
                    transaction.update(roomRef, {...finalState, log: arrayUnion(...logEntries)});
                });
                selectedCards = [];
            } catch (error) { showAlert(error.message); }
        });
        
        passButton.addEventListener('click', async () => {
             const roomRef = doc(db, 'rooms', currentRoomId);
             try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) return;
                    const roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    
                    let newPassCount = roomData.passCount + 1;
                    let newTurnPlayerId = getNextPlayerId(roomData.players, currentPlayer.id, roomData.turnDirection, 0);
                    let newField = roomData.field.map(c => cleanCard(c)); // clean cards on field
                    let newJBack = roomData.isJBackActive;
                    let newDiscardPile = roomData.discardPile;
                    let logEntries = [{ timestamp: Date.now(), message: `${me.name}„Åå„Éë„Çπ„Åó„Åæ„Åó„Åü„ÄÇ` }];
                    
                    const activePlayers = roomData.players.filter(p => p.rank === null);
                    // ‚òÖ‰øÆÊ≠£(1): Ëá™ÂàÜ‰ª•Â§ñ„ÅÆÂÖ®Âì°„Åå„Éë„Çπ„Åó„ÅüÂ†¥Âêà
                    if (roomData.field.length > 0 && newPassCount >= activePlayers.length - 1) {
                        newDiscardPile = [...newDiscardPile, ...newField];
                        newField = [];
                        newPassCount = 0;
                        newJBack = false;
                        // „Çø„Éº„É≥„ÅØÊúÄÂæå„Å´„Ç´„Éº„Éâ„ÇíÂá∫„Åó„Åü„Éó„É¨„Ç§„É§„Éº„Åã„Çâ
                        let nextTurnHolder = roomData.players.find(p => p.id === roomData.lastPlayed.player);
                        // „ÇÇ„Åó„Åù„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅåÊó¢„Å´‰∏ä„Åå„Å£„Å¶„ÅÑ„Åü„Çâ„ÄÅ„Åù„Åì„Åã„ÇâÊ¨°„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Éó„É¨„Ç§„É§„Éº„ÇíÊé¢„Åô
                        if (!nextTurnHolder || nextTurnHolder.rank !== null) {
                            newTurnPlayerId = getNextPlayerId(roomData.players, roomData.lastPlayed.player, roomData.turnDirection, 0);
                        } else {
                            newTurnPlayerId = roomData.lastPlayed.player;
                        }
                        logEntries.push({ timestamp: Date.now(), message: `ÂÖ®Âì°„Åå„Éë„Çπ„Åó„Åü„Åü„ÇÅÂ†¥„ÅåÊµÅ„Çå„Åæ„Åó„Åü„ÄÇÊ¨°„ÅØ ${roomData.players.find(p => p.id === newTurnPlayerId).name}„Åï„Çì„ÅÆÁï™„Åß„Åô„ÄÇ` });
                    }
                    
                    transaction.update(roomRef, {
                        turnPlayerId: newTurnPlayerId, passCount: newPassCount,
                        field: newField, isJBackActive: newJBack,
                        discardPile: newDiscardPile, log: arrayUnion(...logEntries)
                    });
                });
                selectedCards = [];
             } catch (e) { showAlert("„Éë„Çπ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: " + e.message); }
        });

        // --- UI Rendering ---
function renderGame(roomData) {
            roomInfoSpan.textContent = `„É´„Éº„É†ID: ${currentRoomId}`;
            copyRoomIdButton.style.display = 'inline-block';

            if (roomData.gameState === 'finished' && !modalOverlay.classList.contains('visible-modal')) {
                showResultsModal(roomData.players);
            }
            
            const amIHost = roomData.players.find(p => p.id === currentPlayer.id)?.isHost;
            if (amIHost && (roomData.gameState === 'waiting' || roomData.gameState === 'finished')) {
                startGameButton.style.display = 'block';
                startGameButton.textContent = roomData.gameState === 'finished' ? 'Ê¨°„ÅÆ„Ç≤„Éº„É†„ÇíÈñãÂßã' : '„Ç≤„Éº„É†ÈñãÂßã';
            } else {
                startGameButton.style.display = 'none';
            }

            revolutionIcon.style.display = roomData.isRevolution ? 'inline' : 'none';
            jBackIcon.style.display = roomData.isJBackActive ? 'inline' : 'none';
            reverseIcon.style.display = roomData.turnDirection === -1 ? 'inline' : 'none';

            const me = roomData.players.find(p => p.id === currentPlayer.id);
            if (!me) return;

            const sortedPlayers = [...roomData.players].sort((a, b) => a.order - b.order);
            
            playersContainerDiv.innerHTML = '';
            sortedPlayers.forEach(player => {
                if (player.id !== me.id) {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-box';
                    if (player.id === roomData.turnPlayerId) playerDiv.classList.add('is-turn');
                    if (player.rank !== null) playerDiv.classList.add('finished');
                    
                    let cardBacksHTML = '';
                    if (player.hand && player.hand.length > 0) {
                       for (let i = 0; i < player.hand.length; i++) cardBacksHTML += '<div class="card-back"></div>';
                    }
                    const rankText = player.rank ? `${player.rank}‰Ωç` : `ÊâãÊú≠: ${player.hand ? player.hand.length : 0}Êûö`;
                    playerDiv.innerHTML = `<div class="player-name">${player.name}</div><div>${rankText}</div><div class="other-player-cards">${cardBacksHTML}</div>`;
                    playersContainerDiv.appendChild(playerDiv);
                }
            });
            
            if (me.hand) renderMyHand(me, roomData);

            fieldDiv.innerHTML = '';
            roomData.field.forEach(card => fieldDiv.appendChild(createCardElement(card)));

            const turnPlayer = roomData.players.find(p => p.id === roomData.turnPlayerId);
            turnInfoSpan.textContent = turnPlayer ? (turnPlayer.id === me.id ? "„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥„Åß„Åô" : `${turnPlayer.name} „ÅÆ„Çø„Éº„É≥`) : "---";
            
            const lastPlayer = roomData.players.find(p => p.id === roomData.lastPlayed.player);
            lastPlayerInfoSpan.textContent = lastPlayer ? `ÊúÄÂæå„Å´Âá∫„Åó„Åü‰∫∫: ${lastPlayer.name}` : "---";

            const isMyTurn = roomData.turnPlayerId === me.id && me.rank === null;
            playButton.disabled = !isMyTurn || (roomData.pendingActions && roomData.pendingActions.length > 0);

            let disablePass = !isMyTurn || (roomData.pendingActions && roomData.pendingActions.length > 0);
            if (!disablePass && roomData.field.length === 0) {
                // Â†¥„ÅåÁ©∫„ÅÆÊôÇ„ÅØÂü∫Êú¨„Éë„Çπ‰∏çÂèØ
                disablePass = true;
                // ‰æãÂ§ñ: ÊâãÊú≠„ÅåÊÆã„Çä1Êûö„Åß„ÄÅ„Åù„Çå„Åå2„ÅãJoker„ÅÆÂ†¥Âêà„ÅÆ„Åø„Éë„Çπ„ÇíË®±ÂèØ
                if (me.hand && me.hand.length === 1 && (me.hand[0].number === 2 || me.hand[0].suit === 'joker')) {
                    disablePass = false;
                }
            }
            passButton.disabled = disablePass;

            renderLog(roomData.log || []);
        }
        
        function renderMyHand(me, roomData) {
            myHandDiv.innerHTML = '';
            cardUidsInHand.clear();
            if(!me.hand || me.rank !== null) return;

            me.hand.forEach(card => {
                cardUidsInHand.add(card.uid);
                const cardEl = createCardElement(card);
                if (roomData.turnPlayerId === me.id && !roomData.pendingAction) {
                    cardEl.addEventListener('click', () => handleCardClick(card));
                }
                const selectedCardData = selectedCards.find(sc => sc.uid === card.uid);
                if (selectedCardData) {
                    cardEl.classList.add('selected');
                    // Êì¨ÊÖã„Åó„Å¶„ÅÑ„ÇãJoker„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
                    if (selectedCardData.mimics) {
                        cardEl.classList.add('is-transformed');
                        const displayCard = selectedCardData.mimics;
                        const suitSymbols = { spade: '‚ô†', heart: '‚ô•', diamond: '‚ô¶', club: '‚ô£' };
                        cardEl.querySelector('.card-number').textContent = numberToString(displayCard.number);
                        cardEl.querySelector('.suit').textContent = suitSymbols[displayCard.suit];
                    }
                }
                myHandDiv.appendChild(cardEl);
            });
        }
        
        // ‚òÖ‰øÆÊ≠£(7): Joker„ÅÆÈÅ∏ÊäûÂá¶ÁêÜ„ÇíÂÖ®Èù¢ÁöÑ„Å´‰øÆÊ≠£
async function handleCardClick(card) {
            const index = selectedCards.findIndex(c => c.uid === card.uid);

            if (index > -1) { // Card is already selected -> Deselect it
                selectedCards.splice(index, 1);
                const nonJokersLeft = selectedCards.filter(c => c.suit !== 'joker');
                if (nonJokersLeft.length === 0) {
                    selectedCards.forEach(c => {
                        if (c.suit === 'joker') delete c.mimics;
                    });
                }
            } else { // Card is not selected -> Select it
                selectedCards.push(card);
            }
            
            const jokers = selectedCards.filter(c => c.suit === 'joker');
            const nonJokers = selectedCards.filter(c => c.suit !== 'joker');

            if (jokers.length > 0 && nonJokers.length > 0) {
                const untransformedJokers = jokers.filter(j => !j.mimics);
                for (const joker of untransformedJokers) {
                    try {
                        const recommendedNumber = nonJokers[0].number;
                        const mimicData = await showJokerTransformModal(recommendedNumber);
                        joker.mimics = mimicData;
                    } catch (e) {
                        selectedCards = selectedCards.filter(c => c.uid !== joker.uid);
                    }
                }
            }
            
            const roomData = (await getDoc(doc(db, 'rooms', currentRoomId))).data();
            const me = roomData.players.find(p => p.id === currentPlayer.id);
            renderMyHand(me, roomData);
        }

        // --- Helper Functions ---
        function generatePlayerId() { return Math.random().toString(36).substring(2, 10); }
        function generateRoomId() { return Math.random().toString(36).substring(2, 7).toUpperCase(); }
        
        function getCardStrength(card) {
            if (card.suit === 'joker' && !card.mimics) return 99;
            const cardToEval = card.mimics ? card.mimics : card;
            let value = cardToEval.number === 1 ? 14 : (cardToEval.number === 2 ? 15 : cardToEval.number);
            return value;
        }
        
        function getCardValue(card, roomData) {
            const strengthReversed = roomData.isRevolution ^ roomData.isJBackActive; // XOR
            const baseStrength = getCardStrength(card);
            if (card.suit === 'joker' && !card.mimics) return strengthReversed ? 0 : 99; // Pure Joker
            return strengthReversed ? 16 - baseStrength : baseStrength;
        }
        
        function getNextPlayerId(players, currentId, direction, skipCount) {
            const activePlayers = players.filter(p => p.rank === null).sort((a,b) => a.order - b.order);
            if (activePlayers.length === 0) return null;
            if (activePlayers.length === 1) return activePlayers[0].id;
            
            let currentIndex = activePlayers.findIndex(p => p.id === currentId);
            if (currentIndex === -1) { 
                const originalPlayer = players.find(p => p.id === currentId) || { order: -1 };
                const nextOrderedPlayer = activePlayers.find(p => p.order > originalPlayer.order);
                currentIndex = nextOrderedPlayer ? activePlayers.indexOf(nextOrderedPlayer) -1 : activePlayers.length -1;
            }
            
            const totalMoves = 1 + skipCount;
            const nextIndex = (currentIndex + (totalMoves * direction) + activePlayers.length * totalMoves) % activePlayers.length;
            return activePlayers[nextIndex].id;
        }

        function numberToString(num) {
            const map = { 1: 'A', 2: '2', 11: 'J', 12: 'Q', 13: 'K', 15: 'Joker' };
            return map[num] || String(num);
        }

        function cleanCard(card) {
            return { suit: card.suit, number: card.number, uid: card.uid };
        }
        
        function cardsToString(cards) {
            if (cards.length === 0) return "";
            return cards.map(c => {
                if (c.mimics) return `${numberToString(c.number)}->[${numberToString(c.mimics.number)}]`;
                return numberToString(c.suit === 'joker' ? 15 : c.number);
            }).join(', ');
        }

        function createCardElement(card) {
            const el = document.createElement('div');
            el.className = 'card';
            const suitSymbols = { spade: '‚ô†', heart: '‚ô•', diamond: '‚ô¶', club: '‚ô£' };
            
            if (card.suit === 'joker' && !card.mimics) {
                el.classList.add('joker');
                el.innerHTML = `<span class="suit"></span><span class="card-number">JOKER</span><span class="suit"></span>`;
            } else {
                const displayCard = card.mimics ? card.mimics : card;
                const suit = suitSymbols[displayCard.suit];
                const number = numberToString(displayCard.number);
                if (displayCard.suit === 'heart' || displayCard.suit === 'diamond') el.classList.add('red');
                el.innerHTML = `<span class="suit">${suit}</span><span class="card-number">${number}</span><span class="suit">${suit}</span>`;
            }
            if (card.mimics) el.classList.add('is-transformed');
            return el;
        }
        
        function isStair(cards) {
            if (cards.length < 3) return false;
            const cardsToEval = cards.map(c => c.mimics ? { ...c.mimics, uid: c.uid } : c);
            const realCards = cardsToEval.filter(c => c.suit !== 'joker');
            if (realCards.length === 0) return false;

            const suit = realCards[0].suit;
            if (!realCards.every(c => c.suit === suit)) return false;

            const strengths = realCards.map(c => getCardStrength(c)).sort((a,b) => a-b);
            
            // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            for (let i = 0; i < strengths.length - 1; i++) {
                if (strengths[i] === strengths[i+1]) return false;
            }

            let jokersAvailable = cards.length - realCards.length;
            
            for(let i = 0; i < strengths.length - 1; i++) {
                const diff = strengths[i+1] - strengths[i] - 1;
                if (diff < 0) {
                    // ÈÄöÂ∏∏„ÅÇ„Çä„Åà„Å™„ÅÑ„Åå„ÄÅ„ÇΩ„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„ÅßÈáçË§á„Å®Âêå„Åò
                    return false;
                }
                if (diff > 0) {
                    jokersAvailable -= diff;
                }
            }
            
            return jokersAvailable >= 0;
        }
        
        function isValidPlay(playCards, myHand, roomData) {
            if (roomData.field.length === 0 && roomData.lastPlayed.player === null &&
                myHand.some(c => c.suit === 'diamond' && c.number === 3)) {
                if (!playCards.some(c => c.suit === 'diamond' && c.number === 3)) {
                    return { valid: false, message: '„Ç≤„Éº„É†„ÅÆÊúÄÂàù„ÅØ„ÉÄ„Ç§„É§„ÅÆ3„ÇíÂê´„ÇÅ„Å¶Âá∫„ÅôÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ' };
                }
            }
            
            const isOnly2s = playCards.every(c => (c.number === 2 && c.suit !== 'joker') || (c.suit === 'joker' && c.mimics && c.mimics.number === 2));
            if (new Set(playCards.map(c => c.uid)).size === myHand.length && isOnly2s) {
                 return { valid: false, message: '2 („Åæ„Åü„ÅØ2„Å´Êì¨ÊÖã„Åó„ÅüJoker) „ÅÆ„Åø„Åß‰∏ä„Åå„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ' };
            }
            const jokers = playCards.filter(c => c.suit === 'joker');
            const others = playCards.filter(c => c.suit !== 'joker');

            if (jokers.length > 0 && others.length > 0) {
                if (jokers.some(j => !j.mimics)) {
                    return { valid: false, message: '‰ªñ„ÅÆ„Ç´„Éº„Éâ„Å®Âá∫„ÅôÂ†¥Âêà„ÄÅJoker„ÅØÂøÖ„Åö‰Ωï„Åã„Å´Êì¨ÊÖã„Åï„Åõ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
                }
            } 
            else if (jokers.length > 0 && others.length === 0) {
                if (jokers.some(j => j.mimics)) {
                    return { valid: false, message: 'Joker„ÅÆ„Åø„ÅßÂá∫„ÅôÂ†¥Âêà„ÅØÊì¨ÊÖã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ' };
                }
            }

            const cardsToEval = playCards.map(c => c.mimics ? { ...c.mimics, uid: c.uid } : c);
            const isPlayStair = isStair(cardsToEval);
            
            if (!isPlayStair) {
                const realCards = cardsToEval.filter(c => c.suit !== 'joker');
                const playedNumber = realCards.length > 0 ? realCards[0].number : (cardsToEval.length > 0 ? cardsToEval[0].number : null);
                if (!cardsToEval.every(c => c.number === playedNumber)) {
                    return { valid: false, message: 'Âêå„ÅòÊï∞Â≠ó„ÅÆ„Ç´„Éº„Éâ„Åã„ÄÅÈöéÊÆµ„ÅßÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
                }
            }
            
            if (roomData.field.length === 0) return { valid: true };

            if (playCards.length === 1 && playCards[0].suit === 'spade' && playCards[0].number === 3 &&
                roomData.field.length === 1 && roomData.field[0].suit === 'joker' && !roomData.field[0].mimics) {
                return { valid: true };
            }
            
            const isFieldStair = isStair(roomData.field);
            if(isPlayStair !== isFieldStair) return { valid: false, message: 'Â†¥„Å®Âêå„ÅòÁ®ÆÈ°ûÔºàÈÄöÂ∏∏ or ÈöéÊÆµÔºâ„ÅßÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
            if (playCards.length !== roomData.field.length) return { valid: false, message: 'Â†¥„Å®Âêå„ÅòÊûöÊï∞„ÅÆ„Ç´„Éº„Éâ„ÇíÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
            
            let playValue, fieldValue;
            if (isPlayStair) {
                const playBaseCard = playCards.sort((a, b) => getCardStrength(a) - getCardStrength(b))[0];
                const fieldBaseCard = roomData.field.sort((a, b) => getCardStrength(a) - getCardStrength(b))[0];
                playValue = getCardValue(playBaseCard, roomData);
                fieldValue = getCardValue(fieldBaseCard, roomData);
            } else {
                playValue = getCardValue(playCards[0], roomData);
                fieldValue = getCardValue(roomData.field[0], roomData);
            }

            if (playValue <= fieldValue) return { valid: false, message: 'Â†¥„Å´Âá∫„Å¶„ÅÑ„Çã„Ç´„Éº„Éâ„Çà„ÇäÂº∑„ÅÑ„Ç´„Éº„Éâ„ÇíÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
            
            return { valid: true };
        }
        
        // --- Modal and Follow-up Actions ---
        function handlePendingAction(roomData) {
            const action = roomData.pendingActions && roomData.pendingActions[0];
            if (!action || action.actorId !== currentPlayer.id || modalOverlay.classList.contains('visible-modal')) {
                if ((!roomData.pendingActions || roomData.pendingActions.length === 0) && !modalOverlay.classList.contains('hidden')) closeModal();
                return;
            }
            const me = roomData.players.find(p => p.id === currentPlayer.id);
            const targetablePlayers = roomData.players.filter(p => p.id !== me.id && p.rank === null);
            switch(action.type) {
                // ‚òÖ‰øÆÊ≠£(4): ÂäπÊûúÁô∫Âãï„ÇíÂº∑Âà∂„Å´„Åô„Çã„Åü„ÇÅ„ÄÅ„Ç≠„É£„É≥„Çª„É´„Åß„Åç„Å™„ÅÑ„É¢„Éº„ÉÄ„É´„Å´Â§âÊõ¥
                case 'pass_select_player':
                    showPlayerSelectionModal('„Ç´„Éº„Éâ„ÇíÊ∏°„ÅôÁõ∏Êâã„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', targetablePlayers, action.count)
                        .then(targetId => {
                            let newActions = [...roomData.pendingActions];
                            newActions[0] = { ...action, type: 'pass_select_cards', targetId: targetId };
                            updateDoc(doc(db, 'rooms', currentRoomId), { pendingActions: newActions });
                         });
                    break;
                case 'pass_select_cards':
                    showCardSelectionModal('Ê∏°„Åô„Ç´„Éº„Éâ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', me.hand, action.count, true, false)
                        .then(cardsToGive => executeGiveCards(action.targetId, cardsToGive));
                    break;
                case 'discard_select_cards':
                    showCardSelectionModal('Êç®„Å¶„Çã„Ç´„Éº„Éâ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', me.hand, action.count, true, false)
                        .then(cardsToDiscard => executeDiscardCards(cardsToDiscard));
                    break;
                case 'bomber_select_rank':
                     showRankSelectionModal('Á†¥Â£ä„Åô„ÇãÊï∞Â≠ó„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', action.count)
                        .then(ranks => executeBomber(ranks));
                     break;
                case 'collect_select_cards':
                    showCardSelectionModal('ÂõûÂèé„Åô„Çã„Ç´„Éº„Éâ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', roomData.discardPile.map(c => cleanCard(c)), action.count, false, false)
                        .then(cardsToCollect => executeCollectCards(cardsToCollect));
                    break;
                case 'steal_select_player':
                    showPlayerSelectionModal('„Ç´„Éº„Éâ„ÇíÂ•™„ÅÜÁõ∏Êâã„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', targetablePlayers.filter(p => p.hand.length > 0), action.count)
                        .then(targetId => executeStealCard(targetId, action.count));
                    break;
            }
        }
        
        async function clearPendingActions() {
            if (currentRoomId) {
                await updateDoc(doc(db, 'rooms', currentRoomId), { pendingActions: [] });
            }
        }

        function showModal(title, bodyHtml, { confirmText = 'Ê±∫ÂÆö', cancelText = '„Ç≠„É£„É≥„Çª„É´', showConfirm = true, showCancel = true } = {}) {
            modalTitle.textContent = title;
            modalBody.innerHTML = '';
            if (typeof bodyHtml === 'string') modalBody.innerHTML = bodyHtml;
            else modalBody.appendChild(bodyHtml);
            
            modalConfirmButton.textContent = confirmText;
            modalCancelButton.textContent = cancelText;
            modalConfirmButton.style.display = showConfirm ? 'inline-block' : 'none';
            modalCancelButton.style.display = showCancel ? 'inline-block' : 'none';
            modalOverlay.classList.remove('hidden');
            modalOverlay.classList.add('visible-modal');

            return new Promise((resolve, reject) => {
                if (currentModal.reject) currentModal.reject('New modal opened');
                currentModal = { resolve, reject };

                const onConfirm = () => {
                    cleanup();
                    resolve();
                };
                const onCancel = () => {
                    cleanup();
                    reject('User cancelled');
                };
                const cleanup = () => {
                    modalConfirmButton.onclick = null;
                    modalCancelButton.onclick = null;
                    currentModal = {};
                };

                modalConfirmButton.onclick = onConfirm;
                modalCancelButton.onclick = onCancel;
            });
        }
        
        function closeModal() {
            if (currentModal.reject) currentModal.reject('Modal closed externally');
            modalOverlay.classList.add('hidden');
            modalOverlay.classList.remove('visible-modal');
            currentModal = {};
        }

        async function showPlayerSelectionModal(title, players, count) {
            return new Promise((resolve, reject) => {
                const container = document.createElement('div');
                container.className = 'modal-player-selection';
                 if (players.length === 0) {
                    container.textContent = "ÂØæË±°„Å®„Å™„Çã„Éó„É¨„Ç§„É§„Éº„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇÂäπÊûú„ÅØ‰∏çÁô∫„Å´ÁµÇ„Çè„Çä„Åæ„Åô„ÄÇ";
                    setTimeout(() => { closeModal(); reject(); clearPendingAction(); }, 2000);
                 }
                players.forEach(p => {
                    const btn = document.createElement('button');
                    btn.textContent = p.name;
                    btn.onclick = () => { closeModal(); resolve(p.id); };
                    container.appendChild(btn);
                });
                // ‚òÖ‰øÆÊ≠£(4): „Ç≠„É£„É≥„Çª„É´„Éú„Çø„É≥„ÇíÈùûË°®Á§∫„Å´
                showModal(title, container, { showConfirm: false, showCancel: false });
            });
        }
        
        async function showCardSelectionModal(title, availableCards, count, mustSelectAll, allowCancel = true) {
             return new Promise((resolve, reject) => {
                const container = document.createElement('div');
                container.className = 'card-container modal-card-selection';
                let selectedModalCards = [];
                availableCards.forEach(card => {
                    const cardEl = createCardElement(card);
                    cardEl.onclick = () => {
                        const isSelected = selectedModalCards.some(c => c.uid === card.uid);
                        if (isSelected) {
                            selectedModalCards = selectedModalCards.filter(c => c.uid !== card.uid);
                            cardEl.classList.remove('selected');
                        } else if (selectedModalCards.length < count) {
                            selectedModalCards.push(card);
                            cardEl.classList.add('selected');
                        }
                        updateButtonState();
                    };
                    container.appendChild(cardEl);
                });
                const updateButtonState = () => {
                    const requiredCount = mustSelectAll ? Math.min(count, availableCards.length) : count;
                    modalConfirmButton.disabled = selectedModalCards.length !== requiredCount;
                };
                showModal(title, container, { showCancel: allowCancel }).then(() => { closeModal(); resolve(selectedModalCards); }).catch(() => { if(allowCancel) { closeModal(); reject(); } });
                updateButtonState();
            });
        }

        async function showRankSelectionModal(title, count) {
             return new Promise((resolve, reject) => {
                const ranks = [3,4,5,6,7,8,9,10,11,12,13,1,2,15]; // 15 for joker
                const container = document.createElement('div');
                container.className = 'modal-rank-selection';
                let selectedRanks = [];

                ranks.forEach(rank => {
                    const btn = document.createElement('button');
                    btn.textContent = numberToString(rank);
                    btn.onclick = () => {
                        if (selectedRanks.includes(rank)) {
                            selectedRanks = selectedRanks.filter(r => r !== rank);
                            btn.classList.remove('selected');
                        } else if (selectedRanks.length < count) {
                            selectedRanks.push(rank);
                            btn.classList.add('selected');
                        }
                        modalConfirmButton.disabled = selectedRanks.length !== count;
                    };
                    container.appendChild(btn);
                });
                
                // ‚òÖ‰øÆÊ≠£(4): „Ç≠„É£„É≥„Çª„É´„Éú„Çø„É≥„ÇíÈùûË°®Á§∫„Å´
                showModal(`${title} (${count}Á®ÆÈ°ûÈÅ∏Êäû)`, container, { showCancel: false })
                    .then(() => { closeModal(); resolve(selectedRanks); });
                modalConfirmButton.disabled = true;
            });
        }
        
        // ‚òÖ‰øÆÊ≠£(7): JokerÊì¨ÊÖã„É¢„Éº„ÉÄ„É´„ÇíÂÖ®Èù¢ÁöÑ„Å´‰øÆÊ≠£
        async function showJokerTransformModal(recommendedNumber = null) {
            return new Promise((resolve, reject) => {
                const container = document.createElement('div');
                container.className = 'modal-joker-transform';
                
                // --- Recommended Section ---
                if (recommendedNumber) {
                    const p = document.createElement('p');
                    p.innerHTML = `<b>„Åä„Åô„Åô„ÇÅ:</b> „Äå${numberToString(recommendedNumber)}„Äç„Å´Êì¨ÊÖã („Çπ„Éº„Éà„ÇíÈÅ∏Êäû)`;
                    container.appendChild(p);
                    const recommendedContainer = document.createElement('div');
                    ['spade', 'heart', 'diamond', 'club'].forEach(suit => {
                        const btn = document.createElement('button');
                        const cardEl = createCardElement({ suit, number: recommendedNumber });
                        btn.style.width = '80px';
                        btn.style.height = '110px';
                        btn.appendChild(cardEl);
                        btn.onclick = () => { closeModal(); resolve({ suit, number: recommendedNumber }); };
                        recommendedContainer.appendChild(btn);
                    });
                    container.appendChild(recommendedContainer);
                    container.appendChild(document.createElement('hr'));
                }

                // --- Manual Section ---
                const p2 = document.createElement('p');
                p2.innerHTML = '<b>ÊâãÂãïË®≠ÂÆö:</b> Â•Ω„Åç„Å™„Ç´„Éº„Éâ„Å´Êì¨ÊÖã';
                container.appendChild(p2);
                
                const manualContainer = document.createElement('div');
                const ranks = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1, 2];
                let selectedRankEl = null, selectedSuitEl = null;
                let selectedRank = null, selectedSuit = null;
                
                const rankDiv = document.createElement('div');
                rankDiv.style.marginBottom = '10px';
                const pRank = document.createElement('p');
                pRank.textContent = '1. Êï∞Â≠ó„ÇíÈÅ∏Êäû';
                rankDiv.appendChild(pRank);
                ranks.forEach(r => {
                    const btn = document.createElement('button');
                    btn.textContent = numberToString(r);
                    btn.onclick = () => {
                        if (selectedRankEl) selectedRankEl.classList.remove('selected');
                        selectedRank = r;
                        selectedRankEl = btn;
                        btn.classList.add('selected');
                        checkManualSelection();
                    };
                    rankDiv.appendChild(btn);
                });
                manualContainer.appendChild(rankDiv);

                const suitDiv = document.createElement('div');
                const pSuit = document.createElement('p');
                pSuit.textContent = '2. „Çπ„Éº„Éà„ÇíÈÅ∏Êäû';
                suitDiv.appendChild(pSuit);
                ['spade', 'heart', 'diamond', 'club'].forEach(s => {
                    const btn = document.createElement('button');
                    btn.textContent = { spade: '‚ô†', heart: '‚ô•', diamond: '‚ô¶', club: '‚ô£' }[s];
                    btn.style.fontSize = '24px';
                    btn.onclick = () => {
                        if (selectedSuitEl) selectedSuitEl.classList.remove('selected');
                        selectedSuit = s;
                        selectedSuitEl = btn;
                        btn.classList.add('selected');
                        checkManualSelection();
                    };
                    suitDiv.appendChild(btn);
                });
                manualContainer.appendChild(suitDiv);
                container.appendChild(manualContainer);

                const checkManualSelection = () => {
                    modalConfirmButton.disabled = !(selectedRank && selectedSuit);
                };

                showModal('JokerÊì¨ÊÖã', container, { showConfirm: true, confirmText: 'ÊâãÂãïË®≠ÂÆö„ÅßÊ±∫ÂÆö', showCancel: true, cancelText: '„ÇÑ„ÇÅ„Çã' })
                    .then(() => {
                        if (selectedRank && selectedSuit) {
                            resolve({ suit: selectedSuit, number: selectedRank });
                        } else {
                            reject('No manual selection made');
                        }
                    })
                    .catch(() => reject('User cancelled'))
                    .finally(closeModal);
                
                checkManualSelection();
            });
        }
        
        function showResultsModal(players) {
            const sortedPlayers = [...players].sort((a,b) => {
                if (a.rank === null) return 1;
                if (b.rank === null) return -1;
                return a.rank - b.rank;
            });

            let tableHtml = `<table id="results-table"><thead><tr><th>È†Ü‰Ωç</th><th>ÂêçÂâç</th></tr></thead><tbody>`;
            sortedPlayers.forEach(p => {
                const rankDisplay = p.rank ? `${p.rank}‰Ωç` : 'ÊúÄ‰∏ã‰Ωç';
                tableHtml += `<tr><td>${rankDisplay}</td><td>${p.name}</td></tr>`;
            });
            tableHtml += `</tbody></table>`;
            
            showModal('„Ç≤„Éº„É†ÁµêÊûú', tableHtml, { confirmText: '„É´„Éº„É†„Å´Êàª„Çã', showCancel: false })
              .then(() => {
                  closeModal();
              })
              .catch(() => {});
        }


        // --- Game Logic Helpers ---
        function handlePlayerFinish(players, finishedPlayerId) {
            const finishedCount = players.filter(p => p.rank !== null).length;
            const newRank = finishedCount + 1;
            const logs = [];
            const updatedPlayers = players.map(p => {
                if (p.id === finishedPlayerId && p.rank === null) {
                    logs.push({ timestamp: Date.now(), message: `${p.name}„Åå${newRank}‰Ωç„Åß‰∏ä„Åå„Çä„Åæ„Åó„ÅüÔºÅ` });
                    return { ...p, rank: newRank };
                }
                return p;
            });
            return { updatedPlayers, ‰∏ä„Åå„ÇäLog: logs };
        }
        
        function checkGameEnd(state) {
            const activePlayers = state.players.filter(p => p.rank === null);
            if (activePlayers.length <= 1) {
                state.gameState = 'finished';
                if (activePlayers.length === 1) {
                    const lastPlayer = activePlayers[0];
                    const rankCount = state.players.filter(p => p.rank !== null).length;
                    state.players = state.players.map(p => p.id === lastPlayer.id ? {...p, rank: rankCount + 1} : p);
                }
            }
            return state;
        }


        // --- Action Execution Functions ---
        async function executeAction(actionFn, logMessageFn) {
            const roomRef = doc(db, 'rooms', currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room not found");
                    let roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    
                    let { players, discardPile, logContext } = await actionFn(roomData, me);
                    const logMessage = logMessageFn(logContext || {});
                    let logEntries = [{timestamp: Date.now(), message: logMessage}];
                    
                    if (players.find(p => p.id === me.id)?.hand.length === 0) {
                         const { updatedPlayers, ‰∏ä„Åå„ÇäLog } = handlePlayerFinish(players, me.id);
                         players = updatedPlayers;
                         logEntries.push(...‰∏ä„Åå„ÇäLog);
                    }
                    
const newPendingActions = roomData.pendingActions ? roomData.pendingActions.slice(1) : [];
                    
                    let nextState = {
                        players: players,
                        discardPile: discardPile || roomData.discardPile,
                        pendingActions: newPendingActions,
                        turnPlayerId: roomData.turnPlayerId
                    };
                    
                    if (newPendingActions.length === 0) {
                        nextState.turnPlayerId = getNextPlayerId(players, me.id, roomData.turnDirection, 0);
                    }
                    
                    const finalState = checkGameEnd(nextState);
                    transaction.update(doc(db, 'rooms', currentRoomId), {...finalState, log: arrayUnion(...logEntries)});
                });
            } catch (e) {
                showAlert(`„Ç®„É©„Éº: ${e.message}`);
                await clearPendingActions();
            }
        }
        
        function executeGiveCards(targetId, cardsToGive) {
            executeAction(
                (roomData, me) => {
                    const giveUids = new Set(cardsToGive.map(c => c.uid));
                    const newMyHand = me.hand.filter(c => !giveUids.has(c.uid));
                    const targetPlayer = roomData.players.find(p => p.id === targetId);
                    
                    const players = roomData.players.map(p => {
                        if (p.id === me.id) return { ...p, hand: newMyHand };
                        if (p.id === targetId) return { ...p, hand: [...p.hand, ...cardsToGive].sort((a,b) => getCardStrength(a) - getCardStrength(b)) };
                        return p;
                    });
                    return { players, logContext: { target: targetPlayer.name, cards: cardsToGive } };
                },
                (ctx) => `${currentPlayer.name}„Åå${ctx.target}„Å´„Ç´„Éº„Éâ„Çí${ctx.cards.length}ÊûöÊ∏°„Åó„Åæ„Åó„Åü„ÄÇ`
            );
        }
        
        function executeDiscardCards(cardsToDiscard) {
             executeAction(
                (roomData, me) => {
                    const discardUids = new Set(cardsToDiscard.map(c => c.uid));
                    const newMyHand = me.hand.filter(c => !discardUids.has(c.uid));
                    const players = roomData.players.map(p => p.id === me.id ? { ...p, hand: newMyHand } : p);
                    return { players, discardPile: [...roomData.discardPile, ...cardsToDiscard.map(c => cleanCard(c))], logContext: { cards: cardsToDiscard } };
                },
                (ctx) => `${currentPlayer.name}„Åå„Ç´„Éº„Éâ(${cardsToString(ctx.cards)})„ÇíÊç®„Å¶„Åæ„Åó„Åü„ÄÇ`
            );
        }
        
        function executeBomber(ranks) {
            executeAction(
                (roomData, me) => {
                    const rankSet = new Set(ranks);
                    let allDiscarded = [];
                    let finishedPlayerIds = [];

                    const players = roomData.players.map(p => {
                        if (p.rank !== null) return p;
                        const discarded = p.hand.filter(c => rankSet.has(c.number) || (rankSet.has(15) && c.suit === 'joker'));
                        const newHand = p.hand.filter(c => !discarded.find(dc => dc.uid === c.uid));
                        if(discarded.length > 0) allDiscarded.push(...discarded);
                        if(newHand.length === 0 && p.hand.length > 0) finishedPlayerIds.push(p.id);
                        return { ...p, hand: newHand };
                    });

                    if (finishedPlayerIds.length > 0) {
                        const finishedCount = roomData.players.filter(p => p.rank !== null).length;
                        const newRank = finishedCount + 1;
                        finishedPlayerIds.forEach(id => {
                            const pIndex = players.findIndex(p => p.id === id);
                            players[pIndex].rank = newRank;
                        });
                    }

                    return { players, discardPile: [...roomData.discardPile, ...allDiscarded.map(c => cleanCard(c))], logContext: { ranks } };
                },
                (ctx) => `${currentPlayer.name}„ÅåÊï∞Â≠ó[${ctx.ranks.map(numberToString).join(',')}]„ÇíÁ†¥Â£ä„Åó„Åæ„Åó„Åü„ÄÇ`
            );
        }

        function executeCollectCards(cardsToCollect) {
            executeAction(
                (roomData, me) => {
                    const collectUids = new Set(cardsToCollect.map(c => c.uid));
                    const newMyHand = [...me.hand, ...cardsToCollect].sort((a,b) => getCardStrength(a)-getCardStrength(b));
                    const players = roomData.players.map(p => p.id === me.id ? { ...p, hand: newMyHand } : p);
                    return { players, discardPile: roomData.discardPile.filter(c => !collectUids.has(c.uid)), logContext: { cards: cardsToCollect } };
                },
                (ctx) => `${currentPlayer.name}„ÅåÊç®„Å¶Êú≠„Åã„Çâ„Ç´„Éº„Éâ(${cardsToString(ctx.cards)})„ÇíÂõûÂèé„Åó„Åæ„Åó„Åü„ÄÇ`
            );
        }
        
        function executeStealCard(targetId, count) {
            executeAction(
                (roomData, me) => {
                    let target = roomData.players.find(p => p.id === targetId);
                    if (!target || target.hand.length === 0) throw new Error("ÂØæË±°„Å´„Ç´„Éº„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");
                    let targetHand = [...target.hand];
                    let stolenCards = [];
                    for(let i=0; i<count && targetHand.length > 0; i++) {
                        stolenCards.push(targetHand.splice(Math.floor(Math.random() * targetHand.length), 1)[0]);
                    }
                    const newMyHand = [...me.hand, ...stolenCards].sort((a,b) => getCardStrength(a)-getCardStrength(b));
                    const players = roomData.players.map(p => {
                        if (p.id === me.id) return { ...p, hand: newMyHand };
                        if (p.id === targetId) return { ...p, hand: targetHand };
                        return p;
                    });
                    return { players, logContext: { target: target.name, count: stolenCards.length } };
                },
                (ctx) => `${currentPlayer.name}„Åå${ctx.target}„Åã„Çâ„Ç´„Éº„Éâ„Çí${ctx.count}ÊûöÂ•™„ÅÑ„Åæ„Åó„Åü„ÄÇ`
            );
        }
        
        // --- Log and Cut-in ---
        function renderLog(log) {
            if (log.length === lastKnownLogCount) return;

            logMessagesDiv.innerHTML = '';
            log.forEach(entry => {
                const p = document.createElement('p');
                p.textContent = entry.message;
                logMessagesDiv.prepend(p);

                // Cut-in trigger
                if (log.indexOf(entry) >= lastKnownLogCount && entry.effect) {
                    showCutIn(entry.effect.card, entry.effect.name);
                }
            });
            lastKnownLogCount = log.length;
        }

        function showCutIn(cardName, effectName) {
            cutinOverlay.classList.remove('hidden');
            cutinCardName.textContent = cardName;
            cutinEffectName.textContent = effectName;
            cutinOverlay.offsetHeight; // Trigger reflow
            cutinOverlay.classList.add('visible');
            setTimeout(() => {
                cutinOverlay.classList.remove('visible');
                setTimeout(() => cutinOverlay.classList.add('hidden'), 500);
            }, 1500);
        }
        
showLogButton.addEventListener('click', () => logPanel.classList.add('visible'));
        logCloseButton.addEventListener('click', () => logPanel.classList.remove('visible'));

        // Initialize
        showScreen('login');

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>
