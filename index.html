<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç™„É≥„É©„Ç§„É≥Â§ßÂØåË±™ v4</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #004d40; /* Ê∑±„ÅÑÁ∑ë */
            color: #E0E0E0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden; /* For positioning log and cut-in */
        }

        .screen { display: none; }
        .active { display: block; }

        /* Login and Room screens use a light container */
        .container {
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
            width: 100%;
            max-width: 800px;
            text-align: center;
        }
        
        /* Game screen uses the dark theme directly */
        #game-screen.container {
            max-width: 1200px;
            background-color: transparent;
            color: #E0E0E0;
            box-shadow: none;
        }

        h1, h2 {
            color: #004d40;
        }
        
        #game-screen h1, #game-screen h2, #game-screen h3 {
             color: #e0f2f1;
        }

        input[type="text"] {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }

        button {
            background-color: #00796b; /* „ÉÜ„Ç£„Éº„É´„Ç∞„É™„Éº„É≥ */
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #004d40; }
        button:disabled {
            background-color: #999;
            color: #e0e0e0;
            cursor: not-allowed;
        }

        .game-info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 5px;
        }

        .game-status-icons {
            font-size: 32px;
            display: flex;
            gap: 15px;
        }
        
        .players-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            min-height: 120px;
        }

        .player-box {
            border: 2px solid #00796b;
            border-radius: 8px;
            padding: 10px;
            width: 150px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        .player-box.is-turn {
            border-color: #80cbc4; /* Êòé„Çã„ÅÑ„ÉÜ„Ç£„Éº„É´ */
            box-shadow: 0 0 15px #80cbc4;
            font-weight: bold;
            transform: scale(1.05);
        }
        .other-player-cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2px;
            margin-top: 5px;
        }
        .card-back {
            width: 12px;
            height: 18px;
            background-color: #666;
            border: 1px solid white;
            border-radius: 2px;
        }

        .field {
            border: 2px dashed #00796b;
            min-height: 150px;
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            background-color: rgba(0,0,0,0.1);
        }

        .my-hand-container {
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
        }

        .card-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }

        .card {
            border: 1px solid #999;
            border-radius: 5px;
            width: 70px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            background-color: white;
            cursor: pointer;
            user-select: none;
            position: relative;
            padding: 5px;
            box-sizing: border-box;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            color: #333;
            transition: all 0.2s;
        }
        .card.selected {
            transform: translateY(-10px);
            box-shadow: 0 6px 10px #00796b;
            border-color: #00796b;
        }
        .card.red { color: red; }
        .card.joker { background-color: #f0f0f0; }
        .card.is-transformed .card-number {
             color: #00796b;
             font-style: italic;
        }
        .card.is-transformed .suit {
            opacity: 0.6;
        }
        .card .suit { font-size: 1em; }
        .card .card-number { font-size: 1.2em; }


        #room-info {
            margin-top: 20px;
            font-size: 14px;
            color: #a0a0a0;
        }
        
        /* Modal Styles */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #modal-overlay.hidden { display: none; }
        #modal-container {
            background-color: #fff;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            text-align: center;
        }
        #modal-body {
            max-height: 60vh;
            overflow-y: auto;
            margin: 20px 0;
        }
        .modal-card-selection .card { margin: 5px; }
        .modal-player-selection button, .modal-rank-selection button, .modal-joker-transform button {
             width: 100px;
             margin: 5px;
        }
        .modal-rank-selection button.selected {
            background-color: #004d40;
        }


        /* Cut-in Effect */
        #cutin-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }
        #cutin-overlay.visible { opacity: 1; }
        #cutin-box {
            background: rgba(255, 255, 255, 0.9);
            color: #004d40;
            padding: 30px 60px;
            border-radius: 10px;
            text-align: center;
            transform: scale(0.5);
            transition: transform 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        #cutin-overlay.visible #cutin-box { transform: scale(1); }
        #cutin-card-name {
            font-size: 3em;
            font-weight: bold;
            display: block;
        }
        #cutin-effect-name {
            font-size: 2em;
        }

        /* Log Panel */
        #log-panel {
            position: fixed;
            left: -350px;
            top: 0;
            bottom: 0;
            width: 320px;
            background-color: rgba(0, 0, 0, 0.8);
            border-right: 2px solid #00796b;
            display: flex;
            flex-direction: column;
            transition: left 0.3s ease-in-out;
            z-index: 900;
        }
        #log-panel.visible { left: 0; }
        #log-header {
            padding: 10px;
            border-bottom: 1px solid #00796b;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #log-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 14px;
        }
        #log-messages p { margin: 5px 0; }
        #show-log-button {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 901;
        }

    </style>
</head>
<body>

    <div id="login-screen" class="container screen active">
        <h1>„Ç™„É≥„É©„Ç§„É≥Â§ßÂØåË±™</h1>
        <input type="text" id="name-input" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ">
        <button id="login-button">Ê±∫ÂÆö</button>
    </div>

    <div id="room-screen" class="container screen">
        <h1>„É´„Éº„É†ÈÅ∏Êäû</h1>
        <p>„Çà„ÅÜ„Åì„Åù„ÄÅ<span id="player-name-display"></span>„Åï„Çì</p>
        <button id="create-room-button">„É´„Éº„É†„Çí‰ΩúÊàê„Åô„Çã</button>
        <hr style="margin: 20px 0;">
        <input type="text" id="room-id-input" placeholder="„É´„Éº„É†ID„ÇíÂÖ•Âäõ">
        <button id="join-room-button">„É´„Éº„É†„Å´ÂèÇÂä†„Åô„Çã</button>
    </div>

    <div id="game-screen" class="container screen">
        <div class="game-info-bar">
            <div>
                <h2>Â§ßÂØåË±™</h2>
                <span id="turn-info"></span>
            </div>
            <div class="game-status-icons">
                 <span id="revolution-icon" title="Èù©ÂëΩ‰∏≠" style="display:none;">‚öîÔ∏è</span>
                 <span id="j-back-icon" title="J„Éê„ÉÉ„ÇØ‰∏≠" style="display:none;">J</span>
                 <span id="reverse-icon" title="„É™„Éê„Éº„Çπ‰∏≠" style="display:none;">üîÑ</span>
            </div>
        </div>
        
        <div id="players-container" class="players-container"></div>
        
        <h3>Â†¥ (<span id="last-player-info"></span>)</h3>
        <div id="field" class="field"></div>
        
        <div class="my-hand-container">
             <h3>„ÅÇ„Å™„Åü„ÅÆÊâãÊú≠ (<span id="my-name"></span>)</h3>
             <div id="my-hand" class="card-container"></div>
        </div>

        <div id="controls" class="controls">
            <button id="play-button" disabled>Âá∫„Åô</button>
            <button id="pass-button" disabled>„Éë„Çπ</button>
        </div>
        
        <div id="game-controls">
             <button id="start-game-button" style="display: none; background-color: #28a745;">„Ç≤„Éº„É†ÈñãÂßã</button>
        </div>

        <div id="room-info"></div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-container">
            <h2 id="modal-title"></h2>
            <div id="modal-body"></div>
            <div id="modal-actions">
                <button id="modal-confirm-button">Ê±∫ÂÆö</button>
                <button id="modal-cancel-button">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
        </div>
    </div>
    
    <div id="cutin-overlay" class="hidden">
        <div id="cutin-box">
            <span id="cutin-card-name"></span>
            <span id="cutin-effect-name"></span>
        </div>
    </div>

    <div id="log-panel">
        <div id="log-header">
            <h3>„Ç≤„Éº„É†„É≠„Ç∞</h3>
            <button id="log-close-button">√ó</button>
        </div>
        <div id="log-messages"></div>
    </div>
    <button id="show-log-button">„É≠„Ç∞Ë°®Á§∫</button>

    <script type="module">
        // ‚ñº‚ñº‚ñº „Åì„Åì„Å´Firebase„ÅÆË®≠ÂÆö„ÇíË≤º„Çä‰ªò„Åë ‚ñº‚ñº‚ñº
        const firebaseConfig = {
            apiKey: "AIzaSyD1YdTMESZi-ynMzS_p_hdtr1znBI64RmM",
            authDomain: "daifugo-8e039.firebaseapp.com",
            projectId: "daifugo-8e039",
            storageBucket: "daifugo-8e039.firebasestorage.app",
            messagingSenderId: "979025215319",
            appId: "1:979025215319:web:1bf381daf1eb647760c812",
            measurementId: "G-KSQ8LRN4ZE"
        };
        // ‚ñ≤‚ñ≤‚ñ≤ „Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        const showAlert = (message) => { alert(message); };
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Global variables
        let currentPlayer = { id: null, name: null };
        let currentRoomId = null;
        let unsubscribeRoom = null;
        let selectedCards = []; // Stores { suit, number, uid, mimics?: {suit, number} }
        let cardUidsInHand = new Set();
        let currentModal = { resolve: null, reject: null };
        let lastKnownLogCount = 0;

        // DOM Elements
        const screens = { login: document.getElementById('login-screen'), room: document.getElementById('room-screen'), game: document.getElementById('game-screen') };
        const nameInput = document.getElementById('name-input');
        const loginButton = document.getElementById('login-button');
        const playerNameDisplay = document.getElementById('player-name-display');
        const createRoomButton = document.getElementById('create-room-button');
        const joinRoomButton = document.getElementById('join-room-button');
        const roomIdInput = document.getElementById('room-id-input');
        const myHandDiv = document.getElementById('my-hand');
        const playersContainerDiv = document.getElementById('players-container');
        const fieldDiv = document.getElementById('field');
        const turnInfoSpan = document.getElementById('turn-info');
        const lastPlayerInfoSpan = document.getElementById('last-player-info');
        const roomInfoDiv = document.getElementById('room-info');
        const startGameButton = document.getElementById('start-game-button');
        const playButton = document.getElementById('play-button');
        const passButton = document.getElementById('pass-button');
        const myNameSpan = document.getElementById('my-name');
        const revolutionIcon = document.getElementById('revolution-icon');
        const jBackIcon = document.getElementById('j-back-icon');
        const reverseIcon = document.getElementById('reverse-icon');
        // Modal DOM Elements
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalConfirmButton = document.getElementById('modal-confirm-button');
        const modalCancelButton = document.getElementById('modal-cancel-button');
        // Cut-in & Log DOM Elements
        const cutinOverlay = document.getElementById('cutin-overlay');
        const cutinCardName = document.getElementById('cutin-card-name');
        const cutinEffectName = document.getElementById('cutin-effect-name');
        const logPanel = document.getElementById('log-panel');
        const showLogButton = document.getElementById('show-log-button');
        const logCloseButton = document.getElementById('log-close-button');
        const logMessagesDiv = document.getElementById('log-messages');


        // --- Screen Navigation ---
        function showScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            screens[screenName].classList.add('active');
        }

        // --- Login ---
        loginButton.addEventListener('click', () => {
            const name = nameInput.value.trim();
            if (name) {
                currentPlayer.name = name;
                currentPlayer.id = generatePlayerId();
                playerNameDisplay.textContent = name;
                showScreen('room');
            } else { showAlert('ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'); }
        });
        
        // --- Room Creation/Joining ---
        createRoomButton.addEventListener('click', async () => {
            currentRoomId = generateRoomId();
            const roomRef = doc(db, 'rooms', currentRoomId);
            const newPlayer = { id: currentPlayer.id, name: currentPlayer.name, isHost: true, hand: [], order: -1, rank: null };
            await setDoc(roomRef, {
                id: currentRoomId,
                players: [newPlayer],
                gameState: 'waiting',
                field: [], discardPile: [],
                lastPlayed: { player: null, cards: [] },
                turnPlayerId: null, passCount: 0,
                isRevolution: false, isJBackActive: false,
                turnDirection: 1, // 1 for normal, -1 for reverse
                createdAt: serverTimestamp(),
                pendingAction: null,
                log: [{ timestamp: Date.now(), message: `„É´„Éº„É†„Åå‰ΩúÊàê„Åï„Çå„Åæ„Åó„Åü„ÄÇ` }]
            });
            joinRoom(currentRoomId);
        });

        joinRoomButton.addEventListener('click', async () => {
            const roomId = roomIdInput.value.trim();
            if (!roomId) return showAlert('„É´„Éº„É†ID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            const roomRef = doc(db, 'rooms', roomId);
            const roomSnap = await getDoc(roomRef);

            if (!roomSnap.exists()) return showAlert('ÊåáÂÆö„Åï„Çå„Åü„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ');
            const roomData = roomSnap.data();
            if (roomData.players.find(p => p.name === currentPlayer.name)) return showAlert('Âêå„ÅòÂêçÂâç„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅåÊó¢„Å´„É´„Éº„É†„Å´„ÅÑ„Åæ„Åô„ÄÇ');
            if (roomData.players.length >= 6) return showAlert('„Åì„ÅÆ„É´„Éº„É†„ÅØÊ∫ÄÂì°„Åß„Åô„ÄÇ');
            if (roomData.gameState !== 'waiting') return showAlert('„Åì„ÅÆ„Ç≤„Éº„É†„ÅØÊó¢„Å´ÈñãÂßã„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ');

            const newPlayer = { id: currentPlayer.id, name: currentPlayer.name, isHost: false, hand: [], order: -1, rank: null };
            await updateDoc(roomRef, { 
                players: arrayUnion(newPlayer),
                log: arrayUnion({ timestamp: Date.now(), message: `${currentPlayer.name}„Åï„Çì„ÅåÂèÇÂä†„Åó„Åæ„Åó„Åü„ÄÇ` })
            });
            joinRoom(roomId);
        });

        function joinRoom(roomId) {
            currentRoomId = roomId;
            myNameSpan.textContent = currentPlayer.name;
            showScreen('game');
            if (unsubscribeRoom) unsubscribeRoom();
            unsubscribeRoom = onSnapshot(doc(db, 'rooms', currentRoomId), (doc) => {
                if (doc.exists()) {
                    renderGame(doc.data());
                    handlePendingAction(doc.data());
                } else { 
                    showAlert('„É´„Éº„É†„ÅåÂâäÈô§„Åï„Çå„Åæ„Åó„Åü„ÄÇ'); 
                    location.reload(); 
                }
            });
        }
        
        // --- Game Start ---
        startGameButton.addEventListener('click', async () => {
            const roomRef = doc(db, 'rooms', currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room not found.");
                    const roomData = roomSnap.data();

                    if (roomData.players.length < 3) throw new Error('3‰∫∫‰ª•‰∏ä„Åß„Ç≤„Éº„É†„ÇíÈñãÂßã„Åß„Åç„Åæ„Åô„ÄÇ');

                    const suits = ['spade', 'heart', 'diamond', 'club'];
                    let deck = [];
                    suits.forEach(s => { for (let i = 1; i <= 13; i++) deck.push({ suit: s, number: i, uid: `${s}-${i}` }); });
                    deck.push({ suit: 'joker', number: 15, uid: 'joker-1' });
                    deck.push({ suit: 'joker', number: 15, uid: 'joker-2' });
                    deck = deck.sort(() => Math.random() - 0.5);

                    let players = [...roomData.players].sort(() => Math.random() - 0.5);
                    let dia3PlayerId = null;
                    players.forEach(p => { p.hand = []; p.rank = null; });
                    let pIndex = 0;
                    while (deck.length > 0) {
                        const card = deck.pop();
                        players[pIndex].hand.push(card);
                        if (card.suit === 'diamond' && card.number === 3) dia3PlayerId = players[pIndex].id;
                        pIndex = (pIndex + 1) % players.length;
                    }
                    
                    const firstPlayerId = dia3PlayerId || players[0].id;
                    const firstPlayerIndex = players.findIndex(p => p.id === firstPlayerId);
                    const sortedPlayers = [];
                    for (let i = 0; i < players.length; i++) {
                        const p = players[(firstPlayerIndex + i) % players.length];
                        p.order = i + 1;
                        sortedPlayers.push(p);
                    }
                    
                    sortedPlayers.forEach(p => p.hand.sort((a, b) => getCardStrength(a) - getCardStrength(b)));
                    
                    transaction.update(roomRef, {
                        players: sortedPlayers, gameState: 'playing',
                        turnPlayerId: firstPlayerId, field: [],
                        discardPile: [], passCount: 0,
                        lastPlayed: { player: null, cards: [] },
                        isRevolution: false, isJBackActive: false, turnDirection: 1,
                        pendingAction: null,
                        log: arrayUnion({ timestamp: Date.now(), message: `„Ç≤„Éº„É†„ÅåÈñãÂßã„Åï„Çå„Åæ„Åó„Åü„ÄÇÊúÄÂàù„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅØ${sortedPlayers.find(p=>p.id===firstPlayerId).name}„Åï„Çì„Åß„Åô„ÄÇ` })
                    });
                });
            } catch (error) { showAlert(error.message); }
        });

        // --- Game Actions ---
        playButton.addEventListener('click', async () => {
            if (selectedCards.length === 0) return;
            const roomRef = doc(db, 'rooms', currentRoomId);

            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room does not exist.");
                    const roomData = roomSnap.data();

                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    const validation = isValidPlay(selectedCards, me.hand, roomData);
                    if (!validation.valid) throw new Error(validation.message);

                    const playedCardUids = new Set(selectedCards.map(c => c.uid));
                    const newHand = me.hand.filter(c => !playedCardUids.has(c.uid));
                    const playersCopy = roomData.players.map(p => p.id === me.id ? { ...p, hand: newHand } : p);

                    let logEntries = [{ timestamp: Date.now(), message: `${me.name}„Åå${cardsToString(selectedCards)}„ÇíÂá∫„Åó„Åæ„Åó„Åü„ÄÇ` }];

                    let nextState = {
                        players: playersCopy, field: selectedCards, passCount: 0,
                        lastPlayed: { player: me.id, cards: selectedCards },
                        isRevolution: roomData.isRevolution, isJBackActive: roomData.isJBackActive,
                        turnDirection: roomData.turnDirection, turnPlayerId: roomData.turnPlayerId,
                        discardPile: [...roomData.discardPile, ...roomData.field], pendingAction: null
                    };
                    
                    const realCards = selectedCards.filter(c => c.suit !== 'joker' || c.mimics);
                    const playedNumber = realCards[0]?.mimics?.number || realCards[0]?.number;
                    
                    // --- Card Effects ---
                    let clearField = false, isFollowUpAction = false, skipCount = 0;
                    
                    // Joker-Joker pair
                    if (selectedCards.length === 2 && selectedCards.every(c => c.suit === 'joker' && !c.mimics)) {
                        clearField = true;
                        logEntries.push({timestamp: Date.now(), message: "ÊúÄÂº∑„ÅÆJoker„Éö„Ç¢ÔºÅÂ†¥„ÅåÊµÅ„Çå„Åæ„Åô„ÄÇ"});
                    }

                    // Revolution
                    if (selectedCards.length >= 4) {
                        nextState.isRevolution = !nextState.isRevolution;
                        logEntries.push({timestamp: Date.now(), message: `Èù©ÂëΩÁô∫ÁîüÔºÅÂº∑„Åï„Åå${nextState.isRevolution ? 'ÈÄÜËª¢' : 'Ê≠£Â∏∏„Å´'}„Å™„Çä„Åæ„Åó„Åü„ÄÇ`});
                    }
                    
                    if (playedNumber) {
                        const effectMap = {4:"„É™„Éê„Éº„Çπ", 5:"5„Çπ„Ç≠„ÉÉ„Éó", 6:"„Çç„Åè„ÇçÈ¶ñ", 7:"7Ê∏°„Åó", 8:"8Âàá„Çä", 9:"ÊïëÊÄ•Ëªä", 10:"10Êç®„Å¶", 11:"J„Éê„ÉÉ„ÇØ", 12:"Q„Éú„É≥„Éê„Éº", 13:"KÂõûÂèé", 1:"AÂ•™„ÅÑ"};
                        const effectName = effectMap[playedNumber];
                        if(effectName) logEntries.push({ timestamp: Date.now(), message: `ÂäπÊûúÁô∫Âãï: ${numberToString(playedNumber)} - ${effectName}`, effect: {card:numberToString(playedNumber), name: effectName}});

                        switch(playedNumber) {
                            case 4: if (selectedCards.length % 2 !== 0) nextState.turnDirection *= -1; break;
                            case 5:
                                const activePlayersCount = roomData.players.filter(p => p.hand.length > 0 && p.rank === null).length;
                                const skipAmount = 2 * selectedCards.length - 1;
                                if (activePlayersCount > 1 && skipAmount % activePlayersCount === 0) {
                                    clearField = true;
                                    logEntries.push({timestamp: Date.now(), message: "5„Çπ„Ç≠„ÉÉ„Éó„ÅÆÂäπÊûú„ÅßÂ†¥„ÅåÊµÅ„Çå„Åæ„Åó„ÅüÔºÅ"});
                                } else {
                                    skipCount = skipAmount;
                                }
                                break;
                            case 6: case 9: if (selectedCards.length >= 2) clearField = true; break;
                            case 8: clearField = true; break;
                            case 11: nextState.isJBackActive = !nextState.isJBackActive; break;
                            case 3: 
                                if (selectedCards[0].suit === 'spade' && roomData.field.length === 1 && roomData.field[0].suit === 'joker' && !roomData.field[0].mimics) clearField = true;
                                break;
                            // Follow-up actions
                            case 7: 
                                isFollowUpAction = true;
                                nextState.pendingAction = { type: 'pass_select_player', actorId: me.id, count: selectedCards.length };
                                break;
                            case 10:
                                isFollowUpAction = true;
                                nextState.pendingAction = { type: 'discard_select_cards', actorId: me.id, count: selectedCards.length };
                                break;
                            case 12: // Q
                                isFollowUpAction = true;
                                nextState.pendingAction = { type: 'bomber_select_rank', actorId: me.id, count: selectedCards.length };
                                break;
                            case 13: // K
                                isFollowUpAction = true;
                                nextState.pendingAction = { type: 'collect_select_cards', actorId: me.id, count: selectedCards.length };
                                break;
                            case 1: // A
                                isFollowUpAction = true;
                                nextState.pendingAction = { type: 'steal_select_player', actorId: me.id, count: selectedCards.length };
                                break;
                        }
                    }

                    if (isFollowUpAction) {
                        // Just update state and wait for player input
                    } else if (clearField) {
                        nextState.discardPile = [...nextState.discardPile, ...selectedCards];
                        nextState.field = [];
                        nextState.passCount = 0;
                        nextState.turnPlayerId = me.id; // Turn goes to the person who cleared
                        nextState.isJBackActive = false; // J-Back effect ends
                    } else {
                        nextState.turnPlayerId = getNextPlayerId(roomData.players, me.id, nextState.turnDirection, skipCount);
                    }
                    
                    // Win condition check
                    if (newHand.length === 0 && !isFollowUpAction) {
                        logEntries.push({timestamp: Date.now(), message: `${me.name}„Åå‰∏ä„Åå„Çä„Åæ„Åó„ÅüÔºÅ`});
                        const finishedPlayer = nextState.players.find(p => p.id === me.id);
                        if (finishedPlayer) finishedPlayer.rank = 'finished'; // Simple win state
                    }
                    
                    nextState.log = arrayUnion(...logEntries);
                    transaction.update(roomRef, nextState);
                });
                selectedCards = [];
            } catch (error) { showAlert(error.message); }
        });
        
        passButton.addEventListener('click', async () => {
             const roomRef = doc(db, 'rooms', currentRoomId);
             try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) return;
                    const roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    
                    let newPassCount = roomData.passCount + 1;
                    let newTurnPlayerId = getNextPlayerId(roomData.players, currentPlayer.id, roomData.turnDirection, 0);
                    let newField = roomData.field;
                    let newJBack = roomData.isJBackActive;
                    let newDiscardPile = roomData.discardPile;
                    let logEntries = [{ timestamp: Date.now(), message: `${me.name}„Åå„Éë„Çπ„Åó„Åæ„Åó„Åü„ÄÇ` }];
                    
                    const activePlayers = roomData.players.filter(p => p.hand.length > 0 && p.rank === null);
                    if (newPassCount >= activePlayers.length - 1) {
                        newDiscardPile = [...newDiscardPile, ...newField];
                        newField = []; // Clear field
                        newPassCount = 0;
                        newJBack = false; // J-Back effect ends
                        newTurnPlayerId = roomData.lastPlayed.player; // Turn goes to last player
                        logEntries.push({ timestamp: Date.now(), message: `ÂÖ®Âì°„Åå„Éë„Çπ„Åó„Åü„Åü„ÇÅÂ†¥„ÅåÊµÅ„Çå„Åæ„Åó„Åü„ÄÇ` });
                    }
                    
                    transaction.update(roomRef, {
                        turnPlayerId: newTurnPlayerId, passCount: newPassCount,
                        field: newField, isJBackActive: newJBack,
                        discardPile: newDiscardPile, log: arrayUnion(...logEntries)
                    });
                });
             } catch (e) { showAlert("„Éë„Çπ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: " + e.message); }
        });

        // --- UI Rendering ---
        function renderGame(roomData) {
            roomInfoDiv.textContent = `„É´„Éº„É†ID: ${currentRoomId}` + (roomData.gameState === 'waiting' ? ` | ÂèÇÂä†„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...` : '');
            
            const amIHost = roomData.players.find(p => p.id === currentPlayer.id)?.isHost;
            startGameButton.style.display = (amIHost && roomData.gameState === 'waiting') ? 'block' : 'none';

            revolutionIcon.style.display = roomData.isRevolution ? 'inline' : 'none';
            jBackIcon.style.display = roomData.isJBackActive ? 'inline' : 'none';
            reverseIcon.style.display = roomData.turnDirection === -1 ? 'inline' : 'none';

            const me = roomData.players.find(p => p.id === currentPlayer.id);
            if (!me) return;

            const sortedPlayers = [...roomData.players].sort((a, b) => a.order - b.order);
            
            playersContainerDiv.innerHTML = '';
            sortedPlayers.forEach(player => {
                if (player.id !== me.id) {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-box';
                    if (player.id === roomData.turnPlayerId) playerDiv.classList.add('is-turn');
                    let cardBacksHTML = '';
                    if (player.hand && player.hand.length > 0) {
                       for (let i = 0; i < player.hand.length; i++) cardBacksHTML += '<div class="card-back"></div>';
                    }
                    const status = player.rank ? '‰∏ä„Åå„Çä' : `ÊâãÊú≠: ${player.hand ? player.hand.length : 0} Êûö`;
                    playerDiv.innerHTML = `<div class="player-name">${player.name}</div><div>${status}</div><div class="other-player-cards">${cardBacksHTML}</div>`;
                    playersContainerDiv.appendChild(playerDiv);
                }
            });
            
            if (me.hand) renderMyHand(me, roomData);

            fieldDiv.innerHTML = '';
            roomData.field.forEach(card => fieldDiv.appendChild(createCardElement(card)));

            const turnPlayer = roomData.players.find(p => p.id === roomData.turnPlayerId);
            turnInfoSpan.textContent = turnPlayer ? (turnPlayer.id === me.id ? "„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥„Åß„Åô" : `${turnPlayer.name} „ÅÆ„Çø„Éº„É≥`) : "---";
            
            const lastPlayer = roomData.players.find(p => p.id === roomData.lastPlayed.player);
            lastPlayerInfoSpan.textContent = lastPlayer ? `ÊúÄÂæå„Å´Âá∫„Åó„Åü‰∫∫: ${lastPlayer.name}` : "---";

            const isMyTurn = roomData.turnPlayerId === me.id;
            playButton.disabled = !isMyTurn || roomData.pendingAction;
            passButton.disabled = !isMyTurn || roomData.field.length === 0 || roomData.pendingAction;

            renderLog(roomData.log || []);
        }
        
        function renderMyHand(me, roomData) {
            myHandDiv.innerHTML = '';
            cardUidsInHand.clear();
            if(!me.hand) return;

            me.hand.forEach(card => {
                cardUidsInHand.add(card.uid);
                const cardEl = createCardElement(card);
                if (roomData.turnPlayerId === me.id && !roomData.pendingAction) {
                    cardEl.addEventListener('click', () => handleCardClick(card, cardEl));
                }
                const selectedCardData = selectedCards.find(sc => sc.uid === card.uid);
                if (selectedCardData) {
                    cardEl.classList.add('selected');
                    if (selectedCardData.mimics) {
                        cardEl.classList.add('is-transformed');
                        cardEl.querySelector('.card-number').textContent = numberToString(selectedCardData.mimics.number);
                        const suitSymbols = { spade: '‚ô†', heart: '‚ô•', diamond: '‚ô¶', club: '‚ô£' };
                        cardEl.querySelector('.suit').textContent = suitSymbols[selectedCardData.mimics.suit];
                    }
                }
                myHandDiv.appendChild(cardEl);
            });
        }
        
        async function handleCardClick(card, cardEl) {
            const isSelected = selectedCards.some(c => c.uid === card.uid);
            
            if (isSelected) {
                selectedCards = selectedCards.filter(c => c.uid !== card.uid);
            } else {
                let newSelectedCards = [...selectedCards, card];
                const jokers = newSelectedCards.filter(c => c.suit === 'joker');
                const others = newSelectedCards.filter(c => c.suit !== 'joker');

                if (jokers.length > 0 && others.length > 0) { // Joker + other cards
                    try {
                        const targetNumber = others[0].number;
                        // Ask the last added joker to transform
                        const mimicData = await showJokerTransformModal(targetNumber);
                        card.mimics = mimicData; // Add mimics data to the card object
                        selectedCards.push(card);
                    } catch (e) { return; } // User cancelled
                } else {
                    selectedCards.push(card);
                }
            }
             // Re-render hand to reflect selection and transformation state
             const roomData = (await getDoc(doc(db, 'rooms', currentRoomId))).data();
             const me = roomData.players.find(p => p.id === currentPlayer.id);
             renderMyHand(me, roomData);
        }

        // --- Helper Functions ---
        function generatePlayerId() { return Math.random().toString(36).substring(2, 10); }
        function generateRoomId() { return Math.random().toString(36).substring(2, 7).toUpperCase(); }
        
        function getCardStrength(card) {
            if (card.suit === 'joker' && !card.mimics) return 99;
            const cardToEval = card.mimics ? card.mimics : card;
            let value = cardToEval.number === 1 ? 14 : (cardToEval.number === 2 ? 15 : cardToEval.number);
            return value;
        }
        
        function getCardValue(card, roomData) {
            const strengthReversed = roomData.isRevolution ^ roomData.isJBackActive; // XOR
            const baseStrength = getCardStrength(card);
            if (card.suit === 'joker' && !card.mimics) return strengthReversed ? 0 : 99; // Pure Joker
            return strengthReversed ? 16 - baseStrength : baseStrength;
        }
        
        function getNextPlayerId(players, currentId, direction, skipCount) {
            const activePlayers = players.filter(p => p.hand.length > 0 && p.rank === null).sort((a,b) => a.order - b.order);
            if (activePlayers.length === 0) return currentId;
            const currentIndex = activePlayers.findIndex(p => p.id === currentId);
            if (currentIndex === -1) return activePlayers[0]?.id;
            const totalMoves = 1 + skipCount;
            const nextIndex = (currentIndex + (totalMoves * direction) % activePlayers.length + activePlayers.length) % activePlayers.length;
            return activePlayers[nextIndex].id;
        }

        function numberToString(num) {
            const map = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K', 15: 'Joker' };
            return map[num] || String(num);
        }
        
        function cardsToString(cards) {
            if (cards.length === 0) return "";
            return cards.map(c => {
                if (c.mimics) return `[${numberToString(c.mimics.number)}]`;
                return numberToString(c.suit === 'joker' ? 15 : c.number);
            }).join(', ');
        }

        function createCardElement(card) {
            const el = document.createElement('div');
            el.className = 'card';
            const suitSymbols = { spade: '‚ô†', heart: '‚ô•', diamond: '‚ô¶', club: '‚ô£' };
            
            if (card.suit === 'joker' && !card.mimics) {
                el.classList.add('joker');
                el.innerHTML = `<span class="suit"></span><span class="card-number">JOKER</span>`;
            } else {
                const displayCard = card.mimics ? card.mimics : card;
                const suit = suitSymbols[displayCard.suit];
                const number = numberToString(displayCard.number);
                if (displayCard.suit === 'heart' || displayCard.suit === 'diamond') el.classList.add('red');
                el.innerHTML = `<span class="suit">${suit}</span><span class="card-number">${number}</span>`;
            }
            if (card.mimics) el.classList.add('is-transformed');
            return el;
        }
        
        function isStair(cards) {
            if (cards.length < 3) return false;
            const cardsToEval = cards.map(c => c.mimics ? { ...c.mimics, uid: c.uid } : c);
            const realCards = cardsToEval.filter(c => c.suit !== 'joker');
            if (realCards.length === 0) return false;

            const suit = realCards[0].suit;
            if (!realCards.every(c => c.suit === suit)) return false;

            const sortedNumbers = realCards.map(c => getCardStrength(c)).sort((a,b) => a-b);
            let jokersAvailable = cards.length - realCards.length;

            for(let i=0; i < sortedNumbers.length - 1; i++) {
                const diff = sortedNumbers[i+1] - sortedNumbers[i] - 1;
                if (diff < 0) return false; // Duplicate numbers
                if (diff > 0) {
                    if (jokersAvailable >= diff) {
                        jokersAvailable -= diff;
                    } else { return false; }
                }
            }
            return true;
        }
        
        function isValidPlay(playCards, myHand, roomData) {
            if (roomData.field.length === 0 && roomData.lastPlayed.player === null &&
                myHand.some(c => c.suit === 'diamond' && c.number === 3)) {
                if (!playCards.some(c => c.suit === 'diamond' && c.number === 3)) {
                    return { valid: false, message: '„Ç≤„Éº„É†„ÅÆÊúÄÂàù„ÅØ„ÉÄ„Ç§„É§„ÅÆ3„ÇíÂê´„ÇÅ„Å¶Âá∫„ÅôÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ' };
                }
            }
            
            const isOnly2s = playCards.every(c => (c.number === 2 && c.suit !== 'joker') || (c.suit === 'joker' && (!c.mimics || c.mimics.number === 2)));
            if (isOnly2s && playCards.length === myHand.length) {
                return { valid: false, message: '2 („Åæ„Åü„ÅØ2„Å®„Ç∏„Éß„Éº„Ç´„Éº)„Å†„Åë„ÇíÂá∫„Åó„Å¶‰∏ä„Åå„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ' };
            }
            
            // Joker validation
            const jokers = playCards.filter(c => c.suit === 'joker');
            const others = playCards.filter(c => c.suit !== 'joker');
            if (jokers.length > 0 && others.length > 0) {
                if (jokers.some(j => !j.mimics)) return { valid: false, message: '‰ªñ„ÅÆ„Ç´„Éº„Éâ„Å®Âá∫„ÅôÂ†¥Âêà„ÄÅJoker„ÅØÂøÖ„Åö‰Ωï„Åã„Å´Êì¨ÊÖã„Åï„Åõ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
            }
            if (jokers.length > 1 && others.length === 0) { // joker only pair
                 if (jokers.some(j => j.mimics)) return { valid: false, message: 'JokerÂêåÂ£´„ÅßÂá∫„ÅôÂ†¥Âêà„ÅØÊì¨ÊÖã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ' };
            }

            // Cards must be same number or a stair
            const cardsToEval = playCards.map(c => c.mimics ? { ...c.mimics, uid: c.uid } : c);
            const isPlayStair = isStair(cardsToEval);
            const realCards = cardsToEval.filter(c => c.suit !== 'joker');
            const playedNumber = realCards[0]?.number;
            if (!isPlayStair && realCards.length > 0 && !realCards.every(c => c.number === playedNumber)) {
                return { valid: false, message: 'Âêå„ÅòÊï∞Â≠ó„ÅÆ„Ç´„Éº„Éâ„Åã„ÄÅÈöéÊÆµ„ÅßÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
            }
            
            if (roomData.field.length === 0) return { valid: true };

            // Special Case: Spade 3 on single Joker
            if (playCards.length === 1 && playCards[0].suit === 'spade' && playCards[0].number === 3 &&
                roomData.field.length === 1 && roomData.field[0].suit === 'joker' && !roomData.field[0].mimics) {
                return { valid: true };
            }

            // Special Case: Joker x2 pair
            if (playCards.length === 2 && playCards.every(c => c.suit === 'joker' && !c.mimics)) {
                return roomData.field.length === 2 ? { valid: true } : { valid: false, message: 'Joker„Éö„Ç¢„ÅØ2Êûö„ÅÆÂ†¥„Å´„Åó„ÅãÂá∫„Åõ„Åæ„Åõ„Çì„ÄÇ' };
            }
            
            const isFieldStair = isStair(roomData.field);
            if(isPlayStair !== isFieldStair) return { valid: false, message: 'Â†¥„Å®Âêå„ÅòÁ®ÆÈ°ûÔºàÈÄöÂ∏∏ or ÈöéÊÆµÔºâ„ÅßÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
            if (playCards.length !== roomData.field.length) return { valid: false, message: 'Â†¥„Å®Âêå„ÅòÊûöÊï∞„ÅÆ„Ç´„Éº„Éâ„ÇíÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };

            const playValue = getCardValue(playCards.sort((a,b) => getCardValue(b, roomData) - getCardValue(a, roomData))[0], roomData);
            const fieldValue = getCardValue(roomData.field.sort((a,b) => getCardValue(b, roomData) - getCardValue(a, roomData))[0], roomData);

            if (playValue <= fieldValue) return { valid: false, message: 'Â†¥„Å´Âá∫„Å¶„ÅÑ„Çã„Ç´„Éº„Éâ„Çà„ÇäÂº∑„ÅÑ„Ç´„Éº„Éâ„ÇíÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' };
            
            return { valid: true };
        }
        
        // --- Modal and Follow-up Actions ---

        function handlePendingAction(roomData) {
            const action = roomData.pendingAction;
            if (!action || action.actorId !== currentPlayer.id) {
                if (!modalOverlay.classList.contains('hidden')) closeModal();
                return;
            }
            const me = roomData.players.find(p => p.id === currentPlayer.id);
            switch(action.type) {
                case 'pass_select_player':
                    showPlayerSelectionModal('„Ç´„Éº„Éâ„ÇíÊ∏°„ÅôÁõ∏Êâã„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', roomData.players.filter(p => p.id !== me.id), action.count)
                        .then(targetId => updateDoc(doc(db, 'rooms', currentRoomId), { pendingAction: { ...action, type: 'pass_select_cards', targetId: targetId } }))
                        .catch(() => {});
                    break;
                case 'pass_select_cards':
                    showCardSelectionModal('Ê∏°„Åô„Ç´„Éº„Éâ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', me.hand, action.count, true)
                        .then(cardsToGive => executeGiveCards(action.targetId, cardsToGive))
                        .catch(() => {});
                    break;
                 case 'discard_select_cards':
                    showCardSelectionModal('Êç®„Å¶„Çã„Ç´„Éº„Éâ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', me.hand, action.count, true)
                        .then(cardsToDiscard => executeDiscardCards(cardsToDiscard))
                        .catch(() => {});
                    break;
                case 'bomber_select_rank':
                     showRankSelectionModal('Á†¥Â£ä„Åô„ÇãÊï∞Â≠ó„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', action.count)
                        .then(ranks => executeBomber(ranks))
                        .catch(() => {});
                     break;
                case 'collect_select_cards':
                    showCardSelectionModal('ÂõûÂèé„Åô„Çã„Ç´„Éº„Éâ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', roomData.discardPile, action.count, false)
                        .then(cardsToCollect => executeCollectCards(cardsToCollect))
                        .catch(() => {});
                    break;
                case 'steal_select_player':
                    showPlayerSelectionModal('„Ç´„Éº„Éâ„ÇíÂ•™„ÅÜÁõ∏Êâã„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ', roomData.players.filter(p => p.id !== me.id && p.hand.length > 0), action.count)
                        .then(targetId => executeStealCard(targetId, action.count))
                        .catch(() => {});
                    break;
            }
        }
        
        function showModal(title, bodyHtml, { confirmText = 'Ê±∫ÂÆö', cancelText = '„Ç≠„É£„É≥„Çª„É´', showConfirm = true, showCancel = true } = {}) {
            modalTitle.textContent = title;
            modalBody.innerHTML = '';
            if (typeof bodyHtml === 'string') modalBody.innerHTML = bodyHtml;
            else modalBody.appendChild(bodyHtml);
            
            modalConfirmButton.textContent = confirmText;
            modalCancelButton.textContent = cancelText;
            modalConfirmButton.style.display = showConfirm ? 'inline-block' : 'none';
            modalCancelButton.style.display = showCancel ? 'inline-block' : 'none';
            modalOverlay.classList.remove('hidden');

            return new Promise((resolve, reject) => {
                if (currentModal.reject) currentModal.reject('New modal opened');
                currentModal = { resolve, reject };
                modalConfirmButton.onclick = () => resolve();
                modalCancelButton.onclick = () => reject('User cancelled');
            });
        }
        
        function closeModal() {
            if (currentModal.reject) currentModal.reject('Modal closed externally');
            modalOverlay.classList.add('hidden');
            currentModal = {};
        }

        async function showPlayerSelectionModal(title, players, count) {
            return new Promise((resolve, reject) => {
                const container = document.createElement('div');
                container.className = 'modal-player-selection';
                players.forEach(p => {
                    const btn = document.createElement('button');
                    btn.textContent = p.name;
                    btn.onclick = () => { closeModal(); resolve(p.id); };
                    container.appendChild(btn);
                });
                showModal(title, container, { showConfirm: false, showCancel: true }).catch(reject);
            });
        }
        
        async function showCardSelectionModal(title, availableCards, count, mustSelectAll) {
             return new Promise((resolve, reject) => {
                const container = document.createElement('div');
                container.className = 'card-container modal-card-selection';
                let selectedModalCards = [];
                availableCards.forEach(card => {
                    const cardEl = createCardElement(card);
                    cardEl.onclick = () => {
                        const isSelected = selectedModalCards.some(c => c.uid === card.uid);
                        if (isSelected) {
                            selectedModalCards = selectedModalCards.filter(c => c.uid !== card.uid);
                            cardEl.classList.remove('selected');
                        } else if (selectedModalCards.length < count) {
                            selectedModalCards.push(card);
                            cardEl.classList.add('selected');
                        }
                        updateButtonState();
                    };
                    container.appendChild(cardEl);
                });
                const updateButtonState = () => {
                    const requiredCount = mustSelectAll ? Math.min(count, availableCards.length) : count;
                    modalConfirmButton.disabled = selectedModalCards.length !== requiredCount;
                };
                showModal(title, container, { showCancel: true }).then(() => { closeModal(); resolve(selectedModalCards); }).catch(reject);
                updateButtonState();
            });
        }

        async function showRankSelectionModal(title, count) {
             return new Promise((resolve, reject) => {
                const ranks = [1,2,3,4,5,6,7,8,9,10,11,12,13,15]; // 15 for joker
                const container = document.createElement('div');
                container.className = 'modal-rank-selection';
                let selectedRanks = [];

                ranks.forEach(rank => {
                    const btn = document.createElement('button');
                    btn.textContent = numberToString(rank);
                    btn.onclick = () => {
                        if (selectedRanks.includes(rank)) {
                            selectedRanks = selectedRanks.filter(r => r !== rank);
                            btn.classList.remove('selected');
                        } else if (selectedRanks.length < count) {
                            selectedRanks.push(rank);
                            btn.classList.add('selected');
                        }
                        modalConfirmButton.disabled = selectedRanks.length !== count;
                    };
                    container.appendChild(btn);
                });
                
                showModal(`${title} (${count}Á®ÆÈ°ûÈÅ∏Êäû)`, container, { showCancel: true })
                    .then(() => { closeModal(); resolve(selectedRanks); })
                    .catch(reject);
                modalConfirmButton.disabled = true;
            });
        }
        
        async function showJokerTransformModal(targetNumber) {
             return new Promise((resolve, reject) => {
                const suits = ['spade', 'heart', 'diamond', 'club'];
                const container = document.createElement('div');
                container.className = 'modal-joker-transform';
                const p = document.createElement('p');
                p.textContent = `Joker„Çí [${numberToString(targetNumber)}] „Å´Êì¨ÊÖã„Åï„Åõ„Åæ„Åô„ÄÇ„Çπ„Éº„Éà„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ`;
                container.appendChild(p);

                suits.forEach(suit => {
                    const btn = document.createElement('button');
                    const card = createCardElement({ suit: suit, number: targetNumber });
                    btn.appendChild(card);
                    btn.onclick = () => { closeModal(); resolve({ suit, number: targetNumber }); };
                    container.appendChild(btn);
                });

                showModal('JokerÊì¨ÊÖã', container, { showConfirm: false, showCancel: true }).catch(reject);
            });
        }
        
        // --- Action Execution Functions ---
        async function executeAction(actionFn, logMessageFn) {
            const roomRef = doc(db, 'rooms', currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room not found");
                    const roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    const updates = await actionFn(roomData, me);
                    const logMessage = logMessageFn(updates.logContext || {});
                    
                    const isWin = updates.players.find(p => p.id === me.id)?.hand.length === 0;
                    if(isWin) {
                        updates.players.find(p => p.id === me.id).rank = 'finished';
                        updates.log = arrayUnion({timestamp: Date.now(), message: logMessage}, {timestamp: Date.now(), message: `${me.name}„Åå‰∏ä„Åå„Çä„Åæ„Åó„ÅüÔºÅ`});
                    } else {
                        updates.log = arrayUnion({timestamp: Date.now(), message: logMessage});
                    }
                    
                    transaction.update(doc(db, 'rooms', currentRoomId), {
                        ...updates,
                        pendingAction: null,
                        turnPlayerId: getNextPlayerId(updates.players, me.id, roomData.turnDirection, 0)
                    });
                });
            } catch (e) {
                showAlert(`„Ç®„É©„Éº: ${e.message}`);
                await updateDoc(roomRef, { pendingAction: null, turnPlayerId: getNextPlayerId((await getDoc(roomRef)).data().players, currentPlayer.id, 1, 0) });
            }
        }
        
        function executeGiveCards(targetId, cardsToGive) {
            executeAction(
                (roomData, me) => {
                    const giveUids = new Set(cardsToGive.map(c => c.uid));
                    const newMyHand = me.hand.filter(c => !giveUids.has(c.uid));
                    const targetPlayer = roomData.players.find(p => p.id === targetId);
                    
                    const players = roomData.players.map(p => {
                        if (p.id === me.id) return { ...p, hand: newMyHand };
                        if (p.id === targetId) return { ...p, hand: [...p.hand, ...cardsToGive].sort((a,b) => getCardStrength(a) - getCardStrength(b)) };
                        return p;
                    });
                    return { players, logContext: { target: targetPlayer.name, cards: cardsToGive } };
                },
                (ctx) => `${currentPlayer.name}„Åå${ctx.target}„Å´„Ç´„Éº„Éâ„Çí${ctx.cards.length}ÊûöÊ∏°„Åó„Åæ„Åó„Åü„ÄÇ`
            );
        }
        
        function executeDiscardCards(cardsToDiscard) {
             executeAction(
                (roomData, me) => {
                    const discardUids = new Set(cardsToDiscard.map(c => c.uid));
                    const newMyHand = me.hand.filter(c => !discardUids.has(c.uid));
                    const players = roomData.players.map(p => p.id === me.id ? { ...p, hand: newMyHand } : p);
                    return { players, discardPile: [...roomData.discardPile, ...cardsToDiscard], logContext: { cards: cardsToDiscard } };
                },
                (ctx) => `${currentPlayer.name}„Åå„Ç´„Éº„Éâ(${cardsToString(ctx.cards)})„ÇíÊç®„Å¶„Åæ„Åó„Åü„ÄÇ`
            );
        }
        
        function executeBomber(ranks) {
            executeAction(
                (roomData, me) => {
                    const rankSet = new Set(ranks);
                    let allDiscarded = [];
                    const players = roomData.players.map(p => {
                        const discarded = p.hand.filter(c => rankSet.has(c.number) || (rankSet.has(15) && c.suit === 'joker'));
                        allDiscarded.push(...discarded);
                        return { ...p, hand: p.hand.filter(c => !discarded.find(dc => dc.uid === c.uid)) };
                    });
                    return { players, discardPile: [...roomData.discardPile, ...allDiscarded], logContext: { ranks } };
                },
                (ctx) => `${currentPlayer.name}„ÅåÊï∞Â≠ó[${ctx.ranks.map(numberToString).join(',')}]„ÇíÁ†¥Â£ä„Åó„Åæ„Åó„Åü„ÄÇ`
            );
        }

        function executeCollectCards(cardsToCollect) {
            executeAction(
                (roomData, me) => {
                    const collectUids = new Set(cardsToCollect.map(c => c.uid));
                    const newMyHand = [...me.hand, ...cardsToCollect].sort((a,b) => getCardStrength(a)-getCardStrength(b));
                    const players = roomData.players.map(p => p.id === me.id ? { ...p, hand: newMyHand } : p);
                    return { players, discardPile: roomData.discardPile.filter(c => !collectUids.has(c.uid)), logContext: { cards: cardsToCollect } };
                },
                (ctx) => `${currentPlayer.name}„ÅåÊç®„Å¶Êú≠„Åã„Çâ„Ç´„Éº„Éâ(${cardsToString(ctx.cards)})„ÇíÂõûÂèé„Åó„Åæ„Åó„Åü„ÄÇ`
            );
        }
        
        function executeStealCard(targetId, count) {
            executeAction(
                (roomData, me) => {
                    let target = roomData.players.find(p => p.id === targetId);
                    if (!target || target.hand.length === 0) throw new Error("ÂØæË±°„Å´„Ç´„Éº„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");
                    let targetHand = [...target.hand];
                    let stolenCards = [];
                    for(let i=0; i<count && targetHand.length > 0; i++) {
                        stolenCards.push(targetHand.splice(Math.floor(Math.random() * targetHand.length), 1)[0]);
                    }
                    const newMyHand = [...me.hand, ...stolenCards].sort((a,b) => getCardStrength(a)-getCardStrength(b));
                    const players = roomData.players.map(p => {
                        if (p.id === me.id) return { ...p, hand: newMyHand };
                        if (p.id === targetId) return { ...p, hand: targetHand };
                        return p;
                    });
                    return { players, logContext: { target: target.name, count: stolenCards.length } };
                },
                (ctx) => `${currentPlayer.name}„Åå${ctx.target}„Åã„Çâ„Ç´„Éº„Éâ„Çí${ctx.count}ÊûöÂ•™„ÅÑ„Åæ„Åó„Åü„ÄÇ`
            );
        }
        
        // --- Log and Cut-in ---
        function renderLog(log) {
            if (log.length === lastKnownLogCount) return;

            logMessagesDiv.innerHTML = '';
            log.forEach(entry => {
                const p = document.createElement('p');
                p.textContent = entry.message;
                logMessagesDiv.prepend(p);

                // Cut-in trigger
                if (log.indexOf(entry) >= lastKnownLogCount && entry.effect) {
                    showCutIn(entry.effect.card, entry.effect.name);
                }
            });
            lastKnownLogCount = log.length;
        }

        function showCutIn(cardName, effectName) {
            cutinCardName.textContent = cardName;
            cutinEffectName.textContent = effectName;
            cutinOverlay.classList.remove('hidden');
            cutinOverlay.classList.add('visible');
            setTimeout(() => {
                cutinOverlay.classList.remove('visible');
                setTimeout(() => cutinOverlay.classList.add('hidden'), 500);
            }, 1500);
        }
        
        showLogButton.addEventListener('click', () => logPanel.classList.add('visible'));
        logCloseButton.addEventListener('click', () => logPanel.classList.remove('visible'));

        // Initialize
        showScreen('login');
    </script>
</body>
</html>
