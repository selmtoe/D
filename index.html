<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大富豪オンライン</title>
    <style>
                body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #004d40; /* 深い緑 */
            color: #E0E0E0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            /* overflow: hidden; を削除してスクロールを有効化 */
            transition: background-color 0.5s ease;
        }

        body.is-my-turn-bg {
            background-color: #6a2e2e;
        }


        .screen { display: none; }
        .active { display: block; }

        /* Login and Room screens use a light container */
        .container {
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
            width: 100%;
            max-width: 800px;
            text-align: center;
        }
        
        /* Game screen uses the dark theme directly */
        #game-screen.container {
            max-width: 1200px;
            background-color: transparent;
            color: #E0E0E0;
            box-shadow: none;
        }

        h1, h2 {
            color: #004d40;
        }
        
        #game-screen h1, #game-screen h2, #game-screen h3 {
             color: #e0f2f1;
        }

        input[type="text"] {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }

        button {
            background-color: #00796b; /* ティールグリーン */
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #004d40; }
        button:disabled {
            background-color: #999;
            color: #e0e0e0;
            cursor: not-allowed;
        }

        .game-info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 5px;
        }

        .game-status-icons {
            font-size: 32px;
            display: flex;
            gap: 15px;
        }
        
        .players-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap; /* プレイヤーが増えても改行されるように */
            gap: 10px;
            margin-bottom: 20px;
            min-height: 120px;
        }

        .player-box {
            border: 2px solid #00796b;
            border-radius: 8px;
            padding: 10px;
            width: 150px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        .player-box.is-turn {
            border-color: #80cbc4; /* 明るいティール */
            box-shadow: 0 0 15px #80cbc4;
            font-weight: bold;
            transform: scale(1.05);
        }
        .player-box.finished {
            opacity: 0.5;
            border-style: dashed;
        }
        .other-player-cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2px;
            margin-top: 5px;
        }
        .card-back {
            width: 12px;
            height: 18px;
            background-color: #666;
            border: 1px solid white;
            border-radius: 2px;
        }

        .field {
            border: 2px dashed #00796b;
            min-height: 150px;
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            background-color: rgba(0,0,0,0.1);
        }

        .my-hand-container {
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
        }

        .card-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }

        .card {
            border: 1px solid #999;
            border-radius: 5px;
            width: 70px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            background-color: white;
            cursor: pointer;
            user-select: none;
            position: relative;
            padding: 5px;
            box-sizing: border-box;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            color: #333;
            transition: all 0.2s;
        }
        .card.selected {
            transform: translateY(-10px);
            box-shadow: 0 6px 10px #00796b;
            border-color: #00796b;
        }
        .card.red { color: red; }
        .card.joker { background-color: #f0f0f0; }
        .card.is-transformed .card-number {
             color: #00796b;
             font-style: italic;
        }
        .card.is-transformed .suit {
            opacity: 0.6;
        }
        .card .suit { font-size: 1em; }
        .card .card-number { font-size: 1.2em; }


        #room-info-container {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #a0a0a0;
        }
        #copy-room-id-button {
            padding: 5px 10px;
            font-size: 14px;
            min-width: 80px;
        }
        
        /* Modal Styles */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #modal-overlay.hidden { display: none; }
        #modal-container {
            background-color: #fff;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            text-align: center;
        }
        #modal-body {
            max-height: 60vh;
            overflow-y: auto;
            margin: 20px 0;
        }
        .modal-card-selection .card { margin: 5px; }
        .modal-player-selection button, .modal-rank-selection button {
             width: 100px;
             margin: 5px;
        }
        .modal-joker-transform button {
            background-color: #f0f0f0;
            color: #333;
        }
        .modal-joker-transform button.selected {
            background-color: #004d40;
            color: white;
        }
        .modal-rank-selection button.selected {
            background-color: #004d40;
        }

        #results-table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
        }
        #results-table th, #results-table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        #results-table th {
            background-color: #f2f2f2;
        }


        /* Cut-in Effect */
        #cutin-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }
        #cutin-overlay.visible { opacity: 1; }
        #cutin-box {
            background: rgba(255, 255, 255, 0.9);
            color: #004d40;
            padding: 30px 60px;
            border-radius: 10px;
            text-align: center;
            transform: scale(0.5);
            transition: transform 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        #cutin-overlay.visible #cutin-box { transform: scale(1); }
        #cutin-card-name {
            font-size: 3em;
            font-weight: bold;
            display: block;
        }
        #cutin-effect-name {
            font-size: 2em;
        }

        /* Log Panel */
        #log-panel {
            position: fixed;
            left: -350px;
            top: 0;
            bottom: 0;
            width: 320px;
            background-color: rgba(0, 0, 0, 0.8);
            border-right: 2px solid #00796b;
            display: flex;
            flex-direction: column;
            transition: left 0.3s ease-in-out;
            z-index: 900;
        }
        #log-panel.visible { left: 0; }
        #log-header {
            padding: 10px;
            border-bottom: 1px solid #00796b;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #log-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 14px;
        }
        #log-messages p { margin: 5px 0; }
        #show-log-button {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 901;
        }

    </style>
    <link rel="manifest" href="manifest.json">
</head>
<body>

    <div id="login-screen" class="container screen active">
        <h1>オンライン大富豪</h1>
        <input type="text" id="name-input" placeholder="名前を入力してください">
        <button id="login-button">決定</button>
    </div>

        <div id="room-screen" class="container screen">
        <h1>ルーム選択</h1>
        <p>ようこそ、<span id="player-name-display"></span>さん</p>
        <button id="create-room-button">ルームを作成する</button>
        <div id="public-rooms-section" style="margin-top: 20px; text-align: left;">
            <h2>参加可能なルーム一覧 <button id="refresh-rooms-button" style="font-size: 14px; padding: 5px 10px; margin-left: 10px;">更新</button></h2>
            <div id="public-rooms-list" style="margin-top: 10px; max-height: 250px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; border-radius: 5px; background-color: #f9f9f9;">
                <p>ルームを検索中...</p>
            </div>
        </div>
        <hr style="margin: 20px 0;">
        <input type="text" id="room-id-input" placeholder="ルームIDを入力">
        <button id="join-room-button">ルームに参加する</button>
    </div>

    <div id="game-screen" class="container screen">
        <div class="game-info-bar">
            <div>
                <h2>大富豪</h2>
                <span id="turn-info"></span>
            </div>
            <div class="game-status-icons">
                 <span id="revolution-icon" title="革命中" style="display:none;">⚔️</span>
                 <span id="j-back-icon" title="Jバック中" style="display:none;">J</span>
                 <span id="reverse-icon" title="リバース中" style="display:none;">🔄</span>
            </div>
        </div>
        
        <div id="players-container" class="players-container"></div>
        
        <h3>場 (<span id="last-player-info"></span>)</h3>
        <div id="field" class="field"></div>
        
        <div class="my-hand-container">
             <h3>あなたの手札 (<span id="my-name"></span>)</h3>
             <div id="my-hand" class="card-container"></div>
        </div>

        <div id="controls" class="controls">
            <button id="play-button" disabled>出す</button>
            <button id="pass-button" disabled>パス</button>
        </div>
        
        <div id="game-controls">
             <button id="start-game-button" style="display: none; background-color: #28a745;">ゲーム開始</button>
        </div>

        <div id="room-info-container">
            <span id="room-info"></span>
            <button id="copy-room-id-button" style="display: none;">IDコピー</button>
        </div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-container">
            <h2 id="modal-title"></h2>
            <div id="modal-body"></div>
            <div id="modal-actions">
                <button id="modal-confirm-button">決定</button>
                <button id="modal-cancel-button">キャンセル</button>
            </div>
        </div>
    </div>
    
    <div id="cutin-overlay" class="hidden">
        <div id="cutin-box">
            <span id="cutin-card-name"></span>
            <span id="cutin-effect-name"></span>
        </div>
    </div>

    <div id="log-panel">
        <div id="log-header">
            <h3>ゲームログ</h3>
            <button id="log-close-button">×</button>
        </div>
        <div id="log-messages"></div>
    </div>
    <button id="show-log-button">ログ表示</button>

    <script type="module">
        // ▼▼▼ ここにFirebaseの設定を貼り付け ▼▼▼
        const firebaseConfig = {
            apiKey: "AIzaSyD1YdTMESZi-ynMzS_p_hdtr1znBI64RmM",
            authDomain: "daifugo-8e039.firebaseapp.com",
            projectId: "daifugo-8e039",
            storageBucket: "daifugo-8e039.firebasestorage.app",
            messagingSenderId: "979025215319",
            appId: "1:979025215319:web:1bf381daf1eb647760c812",
            measurementId: "G-KSQ8LRN4ZE"
        };
        // ▲▲▲ ここまで ▲▲▲

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion, serverTimestamp, runTransaction, collection, query, where, orderBy, getDocs, limit } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        const showAlert = (message) => { alert(message); };

        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Global variables
        let currentPlayer = { id: null, name: null };
        let currentRoomId = null;
        let unsubscribeRoom = null;
        let selectedCards = []; // Stores { suit, number, uid, mimics?: {suit, number} }
        let cardUidsInHand = new Set();
        let currentModal = { resolve: null, reject: null };
        let lastKnownLogCount = 0;

        // DOM Elements
        const screens = { login: document.getElementById('login-screen'), room: document.getElementById('room-screen'), game: document.getElementById('game-screen') };
        const nameInput = document.getElementById('name-input');
        const loginButton = document.getElementById('login-button');
        const playerNameDisplay = document.getElementById('player-name-display');
        const createRoomButton = document.getElementById('create-room-button');
        const joinRoomButton = document.getElementById('join-room-button');
        const roomIdInput = document.getElementById('room-id-input');
        const refreshRoomsButton = document.getElementById('refresh-rooms-button');
        const publicRoomsListDiv = document.getElementById('public-rooms-list');
        const myHandDiv = document.getElementById('my-hand');

        const playersContainerDiv = document.getElementById('players-container');
        const fieldDiv = document.getElementById('field');
        const turnInfoSpan = document.getElementById('turn-info');
        const lastPlayerInfoSpan = document.getElementById('last-player-info');
        const roomInfoSpan = document.getElementById('room-info');
        const copyRoomIdButton = document.getElementById('copy-room-id-button');
        const startGameButton = document.getElementById('start-game-button');
        const playButton = document.getElementById('play-button');
        const passButton = document.getElementById('pass-button');
        const myNameSpan = document.getElementById('my-name');
        const revolutionIcon = document.getElementById('revolution-icon');
        const jBackIcon = document.getElementById('j-back-icon');
        const reverseIcon = document.getElementById('reverse-icon');
        // Modal DOM Elements
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalConfirmButton = document.getElementById('modal-confirm-button');
        const modalCancelButton = document.getElementById('modal-cancel-button');
        // Cut-in & Log DOM Elements
        const cutinOverlay = document.getElementById('cutin-overlay');
        const cutinCardName = document.getElementById('cutin-card-name');
        const cutinEffectName = document.getElementById('cutin-effect-name');
        const logPanel = document.getElementById('log-panel');
        const showLogButton = document.getElementById('show-log-button');
        const logCloseButton = document.getElementById('log-close-button');
        const logMessagesDiv = document.getElementById('log-messages');


        // --- Screen Navigation ---
        function showScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            screens[screenName].classList.add('active');
            if (screenName === 'room') {
                fetchPublicRooms();
            }
        }


        // --- Login ---
        loginButton.addEventListener('click', () => {
            const name = nameInput.value.trim();
            if (name) {
                currentPlayer.name = name;
                currentPlayer.id = generatePlayerId();
                playerNameDisplay.textContent = name;
                showScreen('room');
                } else { showAlert('名前を入力してください。'); }
        });

        refreshRoomsButton.addEventListener('click', fetchPublicRooms);

        // --- Room Creation/Joining ---
        createRoomButton.addEventListener('click', async () => {
            currentRoomId = generateRoomId();

            const roomRef = doc(db, 'rooms', currentRoomId);
            const newPlayer = { id: currentPlayer.id, name: currentPlayer.name, isHost: true, hand: [], order: -1, rank: null };
            await setDoc(roomRef, {
                id: currentRoomId,
                players: [newPlayer],
                gameState: 'waiting', // waiting, playing, finished
                field: [], discardPile: [], roundPile: [],
                lastPlayed: { player: null, cards: [] },
                turnPlayerId: null, passCount: 0,
                isRevolution: false, isJBackActive: false,
                turnDirection: 1, // 1 for normal, -1 for reverse
                createdAt: serverTimestamp(),

                pendingActions: [],
                log: [{ timestamp: Date.now(), message: `ルームが作成されました。` }]
            });
            joinRoom(currentRoomId);
        });

joinRoomButton.addEventListener('click', async () => {
            const roomId = roomIdInput.value.trim();
            if (!roomId) return showAlert('ルームIDを入力してください。');
            const roomRef = doc(db, 'rooms', roomId);
            const roomSnap = await getDoc(roomRef);

            if (!roomSnap.exists()) return showAlert('指定されたルームが見つかりません。');
            const roomData = roomSnap.data();
            if (roomData.players.find(p => p.name === currentPlayer.name)) return showAlert('同じ名前のプレイヤーが既にルームにいます。');
            if (roomData.players.length >= 6) return showAlert('このルームは満員です。');
            if (roomData.gameState === 'playing') return showAlert('このゲームは既に開始されています。');

            const newPlayer = { id: currentPlayer.id, name: currentPlayer.name, isHost: false, hand: [], order: -1, rank: null };
            await updateDoc(roomRef, { 
                players: arrayUnion(newPlayer),
                                log: arrayUnion({ timestamp: Date.now(), message: `${currentPlayer.name}さんが参加しました。` })
            });
            joinRoom(roomId);
        });

        async function fetchPublicRooms() {
            publicRoomsListDiv.innerHTML = '<p>参加可能なルームを検索中...</p>';
            try {
                const roomsRef = collection(db, 'rooms');
                const q = query(roomsRef,
                    where('gameState', '==', 'waiting'),
                    orderBy('createdAt', 'desc'),
                    limit(20)
                );
                const querySnapshot = await getDocs(q);
                const rooms = [];
                querySnapshot.forEach((doc) => {
                    rooms.push(doc.data());
                });
                renderPublicRooms(rooms);
            } catch (error) {
                console.error("Error fetching public rooms: ", error);
                publicRoomsListDiv.innerHTML = `<p style="color:red; font-weight:bold;">インデックス作成が必要です。下のボックス内のURLを全てコピーしてください。</p><textarea style="width: 100%; height: 80px;">${error.message}</textarea>`;
            }
        }


        function renderPublicRooms(rooms) {
            publicRoomsListDiv.innerHTML = '';
            if (rooms.length === 0) {
                publicRoomsListDiv.innerHTML = '<p>現在参加可能なルームはありません。</p>';
                return;
            }

            const list = document.createElement('ul');
            list.style.listStyle = 'none';
            list.style.padding = '0';
            list.style.margin = '0';

            rooms.forEach(room => {
                // Ensure room has players and createdAt before trying to display
                if (!room.players || !room.createdAt) return;

                const host = room.players.find(p => p.isHost);
                const hostName = host ? host.name : '不明';
                const playerCount = room.players.length;
                const creationTime = new Date(room.createdAt.toDate()).toLocaleString('ja-JP');

                const item = document.createElement('li');
                item.style.display = 'flex';
                item.style.justifyContent = 'space-between';
                item.style.alignItems = 'center';
                item.style.padding = '8px';
                item.style.borderBottom = '1px solid #ddd';

                const infoDiv = document.createElement('div');
                infoDiv.innerHTML = `<strong>${hostName}のルーム</strong> (${playerCount}/6人)<br><small>作成日時: ${creationTime}</small>`;

                const joinBtn = document.createElement('button');
                joinBtn.textContent = '参加';
                joinBtn.onclick = async () => { // ★ asyncキーワードを追加
    try {
        // Prevent joining a full room, just in case
        if (room.players.length >= 6) {
            showAlert('このルームは満員です。');
            fetchPublicRooms(); // Refresh list
            return;
        }
         // Prevent joining with a duplicate name
        if (room.players.find(p => p.name === currentPlayer.name)) {
            showAlert('同じ名前のプレイヤーが既にルームにいます。');
            return;
        }
        
        const roomId = room.id;
        const roomRef = doc(db, 'rooms', roomId);
        
        // 念のため、最新のルーム情報を取得して最終チェック
        const roomSnap = await getDoc(roomRef);
        if (!roomSnap.exists()) {
             showAlert('指定されたルームが見つかりません。リストを更新します。');
             fetchPublicRooms();
             return;
        }
        const roomData = roomSnap.data();
        if (roomData.players.length >= 6) {
            showAlert('このルームは満員です。リストを更新します。');
            fetchPublicRooms();
            return;
        }
        if (roomData.gameState === 'playing') {
            showAlert('このゲームは既に開始されています。リストを更新します。');
            fetchPublicRooms();
            return;
        }

        const newPlayer = { id: currentPlayer.id, name: currentPlayer.name, isHost: false, hand: [], order: -1, rank: null };
        
        await updateDoc(roomRef, { 
            players: arrayUnion(newPlayer),
            log: arrayUnion({ timestamp: Date.now(), message: `${currentPlayer.name}さんが参加しました。` })
        });

        joinRoom(roomId);

    } catch (error) {
        console.error("ルームへの参加に失敗しました: ", error);
        showAlert("ルームへの参加に失敗しました。");
    }
};


                item.appendChild(infoDiv);
                item.appendChild(joinBtn);
                list.appendChild(item);
            });
            publicRoomsListDiv.appendChild(list);
        }
        
        function joinRoom(roomId) {
            currentRoomId = roomId;

            myNameSpan.textContent = currentPlayer.name;
            showScreen('game');
            if (unsubscribeRoom) unsubscribeRoom();

            let shownPrivateEvents = new Set();

            unsubscribeRoom = onSnapshot(doc(db, 'rooms', currentRoomId), (doc) => {
                if (doc.exists()) {
                    const roomData = doc.data();
                    renderGame(roomData);

                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    if (me && me.privateEvent && !shownPrivateEvents.has(me.privateEvent.id)) {
                        const event = me.privateEvent;
                        if (event.type === 'steal_success') {
                            showCutIn(cardsToString(event.cards), `[${event.target}]から奪った`);
                        } else if (event.type === 'stolen') {
                            showCutIn(cardsToString(event.cards), `[${event.actor}]に奪われた`);
                        } else if (event.type === 'receive_cards') {
                            showCutIn(cardsToString(event.cards), `[${event.actor}]から渡された`);
                        }
                        shownPrivateEvents.add(event.id);
                    }

                    if(roomData.gameState !== 'finished') {
                         handlePendingAction(roomData);
                    }
                } else {
                    showAlert('ルームが削除されました。'); 
                    location.reload(); 
                }
            });
        }
        
        copyRoomIdButton.addEventListener('click', () => {
            navigator.clipboard.writeText(currentRoomId).then(() => {
                copyRoomIdButton.textContent = 'コピー完了!';
                setTimeout(() => { copyRoomIdButton.textContent = 'IDコピー'; }, 1500);
            });
        });

        // --- Game Start ---
        startGameButton.addEventListener('click', async () => {
            const roomRef = doc(db, 'rooms', currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room not found.");
                    const roomData = roomSnap.data();

                    if (roomData.players.length < 3) throw new Error('3人以上でゲームを開始できます。');

                    const suits = ['spade', 'heart', 'diamond', 'club'];
                    let deck = [];
                    suits.forEach(s => { for (let i = 1; i <= 13; i++) deck.push({ suit: s, number: i, uid: `${s}-${i}` }); });
                    deck.push({ suit: 'joker', number: 15, uid: 'joker-1' });
                    deck.push({ suit: 'joker', number: 15, uid: 'joker-2' });
                    deck = deck.sort(() => Math.random() - 0.5);

                    let players = [...roomData.players].sort(() => Math.random() - 0.5);
                    let dia3PlayerId = null;
                    players.forEach(p => { p.hand = []; p.rank = null; });
                    let pIndex = 0;
                    while (deck.length > 0) {
                        const card = deck.pop();
                        players[pIndex].hand.push(card);
                        if (card.suit === 'diamond' && card.number === 3) dia3PlayerId = players[pIndex].id;
                        pIndex = (pIndex + 1) % players.length;
                    }
                    
                    const firstPlayerId = dia3PlayerId || players[0].id;
                    const firstPlayerIndex = players.findIndex(p => p.id === firstPlayerId);
                    const sortedPlayers = [];
                    for (let i = 0; i < players.length; i++) {
                        const p = players[(firstPlayerIndex + i) % players.length];
                        p.order = i + 1;
                        sortedPlayers.push(p);
                    }
                    
                    sortedPlayers.forEach(p => p.hand.sort((a, b) => getCardStrength(a) - getCardStrength(b)));
                    
                    transaction.update(roomRef, {
                        players: sortedPlayers, gameState: 'playing',
                        turnPlayerId: firstPlayerId, field: [],
                        discardPile: [], passCount: 0,
                        lastPlayed: { player: null, cards: [] },
                        isRevolution: false, isJBackActive: false, turnDirection: 1,
                        pendingActions: [],
                        log: arrayUnion({ timestamp: Date.now(), message: `ゲームが開始されました。最初のプレイヤーは${sortedPlayers.find(p=>p.id===firstPlayerId).name}さんです。` })
                    });
                });
            } catch (error) { showAlert(error.message); }
        });

        // --- Game Actions ---
        playButton.addEventListener('click', async () => {
            if (selectedCards.length === 0) return;
            const roomRef = doc(db, 'rooms', currentRoomId);

            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room does not exist.");
                    const roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    const validation = isValidPlay(selectedCards, me.hand, roomData);
                    if (!validation.valid) throw new Error(validation.message);

                    const playedCardUids = new Set(selectedCards.map(c => c.uid));
                    const newHand = me.hand.filter(c => !playedCardUids.has(c.uid));
                    let playersCopy = roomData.players.map(p => p.id === me.id ? { ...p, hand: newHand } : p);

                    const cleanedPlayedCards = selectedCards.map(c => ({ suit: c.suit, number: c.number, uid: c.uid }));
                    let logEntries = [{ timestamp: Date.now(), message: `${me.name}が${cardsToString(selectedCards)}を出しました。` }];

                    let nextState = {
                        players: playersCopy, field: cleanedPlayedCards, passCount: 0,
                        lastPlayed: { player: me.id, cards: cleanedPlayedCards },
                        isRevolution: roomData.isRevolution, isJBackActive: roomData.isJBackActive,
  

                      turnDirection: roomData.turnDirection, turnPlayerId: roomData.turnPlayerId,
                        discardPile: roomData.discardPile,
                        roundPile: [...roomData.roundPile, ...roomData.field.map(c => cleanCard(c))],
                        pendingActions: []
                    };
                    let clearField = false, skipCount = 0;


                    const isPlayStair = isStair(selectedCards);


                   if (isPlayStair) {
                        logEntries.push({ timestamp: Date.now(), message: "階段です！効果を順次処理します。" });
                        let effectsToProcess = selectedCards.map(c => (c.mimics ? c.mimics : c).number);
                        const hasEightCut = effectsToProcess.includes(8);
                        if(hasEightCut) effectsToProcess = effectsToProcess.filter(n => n !== 8);
                        
                        if (effectsToProcess.includes(11)) {
                            nextState.isJBackActive = !nextState.isJBackActive;
                            logEntries.push({ timestamp: Date.now(), message: `階段効果: Jバック発動！`, effect: {card:"J", name: "Jバック"}});
                            effectsToProcess = effectsToProcess.filter(n => n !== 11);
                        }
                        
                        if (selectedCards.length >= 4) {
                            nextState.isRevolution = !nextState.isRevolution;
                            logEntries.push({timestamp: Date.now(), message: `階段効果: 革命発生！強さが${nextState.isRevolution ? '逆転' : '正常に'}なりました。`, effect: {card: "階段革命", name: ""}});
                        }

                        const strengthReversed = nextState.isRevolution ^ nextState.isJBackActive;
                        effectsToProcess.sort((a, b) => {
                            const valA = getCardValue({number: a}, nextState);
                            const valB = getCardValue({number: b}, nextState);
                            return valA - valB;
                        });

                        if (effectsToProcess.includes(13)) {
                           effectsToProcess = effectsToProcess.filter(n => n !== 13);
                           effectsToProcess.unshift(13);
                        }
                        
                        const actionTypeMap = { 1:'steal_select_player', 7:'pass_select_player', 10:'discard_select_cards', 12:'bomber_select_rank', 13:'collect_select_cards' };
                        effectsToProcess.forEach(num => {
                             const effectMap = {1:"A奪い",4:"リバース", 5:"5スキップ", 7:"7渡し", 10:"10捨て", 12:"Qボンバー", 13:"K回収"};
                             if(effectMap[num]) {
                                 logEntries.push({ timestamp: Date.now(), message: `階段効果: ${numberToString(num)} - ${effectMap[num]}`, effect: {card:numberToString(num), name: effectMap[num]}});
                             }
                            switch(num) {
                                case 4: nextState.turnDirection *= -1; break;
                                case 5: skipCount++; break;
                                case 7: case 10: case 12: case 13: case 1:
                                    nextState.pendingActions.push({ type: actionTypeMap[num], actorId: me.id, count: 1 });
                                    break;
                            }
                                                });

                        if (hasEightCut) {
                            nextState.pendingActions.push({ type: 'eight_cut', actorId: me.id, count: 1 });
                            logEntries.push({ timestamp: Date.now(), message: `階段効果: 8 - 8切り`, effect: {card:"8", name: "8切り"}});
                        }
                        
                    } else {

                        const realCards = selectedCards.map(c => c.mimics ? c.mimics : c).filter(c => c.suit !== 'joker');
                        const playedNumber = realCards.length > 0 ? realCards[0].number : null;
                        
                        if (selectedCards.length === 2 && selectedCards.every(c => c.suit === 'joker' && !c.mimics)) {
                            clearField = true;
                            logEntries.push({timestamp: Date.now(), message: "最強のJokerペア！場が流れます。"});
                        }
                        if (selectedCards.length >= 4) {
                            nextState.isRevolution = !nextState.isRevolution;
                            logEntries.push({timestamp: Date.now(), message: `革命発生！強さが${nextState.isRevolution ? '逆転' : '正常に'}なりました。`, effect: {card: "革命", name: ""}});
                        }
                        
                        if (playedNumber) {
                            const effectMap = {1:"A奪い",/*3:"スペ3返し",*/ 5:"5スキップ", 7:"7渡し", 8:"8切り", 10:"10捨て", 11:"Jバック", 12:"Qボンバー", 13:"K回収"};
                            const effectName = effectMap[playedNumber];
                            if(effectName) logEntries.push({ timestamp: Date.now(), message: `効果発動: ${numberToString(playedNumber)} - ${effectName}`, effect: {card:numberToString(playedNumber), name: effectName}});
                            switch(playedNumber) {
                                case 4: 
                                    if (selectedCards.length % 2 !== 0) {
                                        nextState.turnDirection *= -1;
                                        logEntries.push({ timestamp: Date.now(), message: `効果発動: 4 - リバース`, effect: {card:"4", name: "リバース"}});
                                    }
                                    break;
                                case 5:
                                    const activePlayersCount = roomData.players.filter(p => p.rank === null).length;
                                    if (activePlayersCount <= 1) break;
                                    const skipAmount = (2 * selectedCards.length) - 1;
                                    const totalMoves = 1 + skipAmount;
                                    if (activePlayersCount > 1 && totalMoves % activePlayersCount === 0) {
                                        clearField = true;
                                        logEntries.push({timestamp: Date.now(), message: "5スキップの効果で場が流れました！"});
                                    } else {
                                        skipCount = skipAmount;
                                    }
                                    break;
                                case 6: case 9: 
                                    if (selectedCards.length >= 2) {
                                        clearField = true;
                                        const specificEffectName = playedNumber === 6 ? "ろくろ首" : "救急車";
                                        logEntries.push({ timestamp: Date.now(), message: `効果発動: ${numberToString(playedNumber)} - ${specificEffectName}`, effect: {card:numberToString(playedNumber), name: specificEffectName}});
                                    }
                                    break;
                                case 8: 
                                    clearField = true;
                                    logEntries.push({ timestamp: Date.now(), message: `効果発動: 8 - 8切り`, effect: {card:"8", name: "8切り"}});
                                    break;
                                case 11: nextState.isJBackActive = !nextState.isJBackActive; break;
                                case 3: 
                                    if (selectedCards.length === 1 && selectedCards[0].suit === 'spade' && roomData.field.length === 1 && roomData.field[0].suit === 'joker' && !roomData.field[0].mimics) {
                                         clearField = true;
                                         logEntries.push({ timestamp: Date.now(), message: `効果発動: スペード3返し！`, effect: {card:"スペード3", name: "スペ3返し"}});
                                    }
                                    break;
                                case 7: case 10: case 12: case 13: case 1:
                                    const actionTypeMap = { 1:'steal_select_player', 7:'pass_select_player', 10:'discard_select_cards', 12:'bomber_select_rank', 13:'collect_select_cards' };
                                    nextState.pendingActions.push({ type: actionTypeMap[playedNumber], actorId: me.id, count: selectedCards.length });
                                    break;
                            }
                        }
                    }

                                        if (newHand.length === 0) {
                        const { updatedPlayers, 上がりLog } = handlePlayerFinish(nextState.players, me.id);
                        nextState.players = updatedPlayers;
                        logEntries.push(...上がりLog);
                        nextState.pendingActions = [];
}
                    
                    const remainingPlayers = nextState.players.filter(p => p.rank === null).length;
if (nextState.pendingActions.length > 0) {
                        nextState.turnPlayerId = me.id;
} else if (clearField || remainingPlayers <= 1) {
                        nextState.discardPile = [...roomData.discardPile, ...nextState.roundPile, ...nextState.field];
nextState.field = [];
                        nextState.roundPile = [];
                        nextState.passCount = 0;
                        const playerWhoPlayed = nextState.players.find(p => p.id === me.id);

if (playerWhoPlayed && playerWhoPlayed.rank !== null) {

                            nextState.turnPlayerId = getNextPlayerId(nextState.players, me.id, nextState.turnDirection, 0);
                        } else {
                            nextState.turnPlayerId = me.id;
                        }
                        nextState.isJBackActive = false;
} else {
                        nextState.turnPlayerId = getNextPlayerId(nextState.players, me.id, nextState.turnDirection, skipCount);
}
                    
                    const finalState = checkGameEnd(nextState);

                    transaction.update(roomRef, {...finalState, log: arrayUnion(...logEntries)});
                });
                selectedCards = [];
            } catch (error) { showAlert(error.message); }
        });
        
                passButton.addEventListener('click', async () => {
             playButton.disabled = true;
             passButton.disabled = true;
             const roomRef = doc(db, 'rooms', currentRoomId);
             try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);

                    if (!roomSnap.exists()) return;
                    const roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    
                    let newPassCount = roomData.passCount + 1;
                    let newTurnPlayerId = getNextPlayerId(roomData.players, currentPlayer.id, roomData.turnDirection, 0);
                    let newField = roomData.field.map(c => cleanCard(c)); // clean cards on field
                    let newJBack = roomData.isJBackActive;
                    let newDiscardPile = roomData.discardPile;
                    let logEntries = [{ timestamp: Date.now(), message: `${me.name}がパスしました。` }];
                    
                    const activePlayers = roomData.players.filter(p => p.rank === null);
                    const lastPlayer = roomData.players.find(p => p.id === roomData.lastPlayed.player);
                    const lastPlayerHasFinished = lastPlayer && lastPlayer.rank !== null;
                    
                    let flow = false;
                    if (roomData.field.length > 0 && activePlayers.length > 0) {
                        if (lastPlayerHasFinished) {
                            if (newPassCount >= activePlayers.length) {
                                flow = true;
                            }
                        } else {
                            if (newTurnPlayerId === roomData.lastPlayed.player && activePlayers.length > 1) {
                                flow = true;
}
                        }
                    }

                    if (flow) {
                        newDiscardPile = [...roomData.discardPile, ...roomData.roundPile, ...newField];
newField = [];
                        newPassCount = 0;
                        newJBack = false;
                        
                        let nextTurnHolder = roomData.players.find(p => p.id === roomData.lastPlayed.player);
if (!nextTurnHolder || nextTurnHolder.rank !== null) {
                            newTurnPlayerId = getNextPlayerId(roomData.players, roomData.lastPlayed.player, roomData.turnDirection, 0);
} else {
                            newTurnPlayerId = roomData.lastPlayed.player;
}
                        logEntries.push({ timestamp: Date.now(), message: `全員がパスしたため場が流れました。次は ${roomData.players.find(p => p.id === newTurnPlayerId).name}さんの番です。` });
}

                    
                    transaction.update(roomRef, {

                        turnPlayerId: newTurnPlayerId, passCount: newPassCount,
                        field: newField, isJBackActive: newJBack,
     
                        roundPile: flow ? [] : roomData.roundPile,
     
                   discardPile: newDiscardPile, log: arrayUnion(...logEntries)
                    });
});
                selectedCards = [];

             } catch (e) { showAlert("パスに失敗しました: " + e.message);
                         }
        });

        // --- UI Rendering ---
function renderGame(roomData) {
            roomInfoSpan.textContent = `ルームID: ${currentRoomId}`;
            copyRoomIdButton.style.display = 'inline-block';

            if (roomData.gameState === 'finished' && !modalOverlay.classList.contains('visible-modal')) {
                showResultsModal(roomData.players);
            }
            
            const amIHost = roomData.players.find(p => p.id === currentPlayer.id)?.isHost;
            if (amIHost && (roomData.gameState === 'waiting' || roomData.gameState === 'finished')) {
                startGameButton.style.display = 'block';
                startGameButton.textContent = roomData.gameState === 'finished' ? '次のゲームを開始' : 'ゲーム開始';
            } else {
                startGameButton.style.display = 'none';
            }

            revolutionIcon.style.display = roomData.isRevolution ? 'inline' : 'none';
            jBackIcon.style.display = roomData.isJBackActive ? 'inline' : 'none';
            reverseIcon.style.display = roomData.turnDirection === -1 ? 'inline' : 'none';

            const me = roomData.players.find(p => p.id === currentPlayer.id);
            if (!me) return;

            const sortedPlayers = [...roomData.players].sort((a, b) => a.order - b.order);
            
            playersContainerDiv.innerHTML = '';
            sortedPlayers.forEach(player => {
                if (player.id !== me.id) {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-box';
                    if (player.id === roomData.turnPlayerId) playerDiv.classList.add('is-turn');
                    if (player.rank !== null) playerDiv.classList.add('finished');
                    
                    let cardBacksHTML = '';
                    if (player.hand && player.hand.length > 0) {
                       for (let i = 0; i < player.hand.length; i++) cardBacksHTML += '<div class="card-back"></div>';
                    }
                    const rankText = player.rank ? `${player.rank}位` : `手札: ${player.hand ? player.hand.length : 0}枚`;
                    playerDiv.innerHTML = `<div class="player-name">${player.name}</div><div>${rankText}</div><div class="other-player-cards">${cardBacksHTML}</div>`;
                    playersContainerDiv.appendChild(playerDiv);
                }
            });
            
            if (me.hand) renderMyHand(me, roomData);

            fieldDiv.innerHTML = '';
            roomData.field.forEach(card => fieldDiv.appendChild(createCardElement(card)));

            const turnPlayer = roomData.players.find(p => p.id === roomData.turnPlayerId);
            turnInfoSpan.textContent = turnPlayer ? (turnPlayer.id === me.id ? "あなたのターンです" : `${turnPlayer.name} のターン`) : "---";
            
            const lastPlayer = roomData.players.find(p => p.id === roomData.lastPlayed.player);
            lastPlayerInfoSpan.textContent = lastPlayer ? `最後に出した人: ${lastPlayer.name}` : "---";

            const isMyTurn = roomData.turnPlayerId === me.id && me.rank === null;
            playButton.disabled = !isMyTurn || (roomData.pendingActions && roomData.pendingActions.length > 0);

            let disablePass = !isMyTurn || (roomData.pendingActions && roomData.pendingActions.length > 0);
            if (!disablePass && roomData.field.length === 0) {
                // 場が空の時は基本パス不可
                disablePass = true;
                // 例外: 手札が残り1枚で、それが2かJokerの場合のみパスを許可
                if (me.hand && me.hand.length === 1 && (me.hand[0].number === 2 || me.hand[0].suit === 'joker')) {
                    disablePass = false;
                }
                        }
                            passButton.disabled = disablePass;
            renderLog(roomData.log || []);

            const isMyTurnAndActive = isMyTurn && me.rank === null;
            if (isMyTurnAndActive) {
                document.body.classList.add('is-my-turn-bg');
            } else {
                document.body.classList.remove('is-my-turn-bg');
            }
        }



        
                function renderMyHand(me, roomData) {
            myHandDiv.innerHTML = '';
            cardUidsInHand.clear();
            if (!me.hand) return;

            if (me.rank !== null) {
                myHandDiv.innerHTML = `<h2 style="color: #e0f2f1; text-align: center;">${me.rank}位で上がりました！</h2>`;
                return;
            }

            me.hand.forEach(card => {

                cardUidsInHand.add(card.uid);
                const cardEl = createCardElement(card);
                if (roomData.turnPlayerId === me.id && !roomData.pendingAction) {
                    cardEl.addEventListener('click', () => handleCardClick(card));
                }
                const selectedCardData = selectedCards.find(sc => sc.uid === card.uid);
                if (selectedCardData) {
                    cardEl.classList.add('selected');
                    // 擬態しているJokerの表示を更新
                    if (selectedCardData.mimics) {
                        cardEl.classList.add('is-transformed');
                        const displayCard = selectedCardData.mimics;
                        const suitSymbols = { spade: '♠', heart: '♥', diamond: '♦', club: '♣' };
                        cardEl.querySelector('.card-number').textContent = numberToString(displayCard.number);
                        cardEl.querySelector('.suit').textContent = suitSymbols[displayCard.suit];
                    }
                }
                myHandDiv.appendChild(cardEl);
            });
        }
        
        // ★修正(7): Jokerの選択処理を全面的に修正
async function handleCardClick(card) {
            const index = selectedCards.findIndex(c => c.uid === card.uid);

            if (index > -1) { // Card is already selected -> Deselect it
                selectedCards.splice(index, 1);
                const nonJokersLeft = selectedCards.filter(c => c.suit !== 'joker');
                if (nonJokersLeft.length === 0) {
                    selectedCards.forEach(c => {
                        if (c.suit === 'joker') delete c.mimics;
                    });
                }
            } else { // Card is not selected -> Select it
                selectedCards.push(card);
            }
            
            const jokers = selectedCards.filter(c => c.suit === 'joker');
            const nonJokers = selectedCards.filter(c => c.suit !== 'joker');

            if (jokers.length > 0 && nonJokers.length > 0) {
                const untransformedJokers = jokers.filter(j => !j.mimics);
                for (const joker of untransformedJokers) {
                    try {
                        const recommendedNumber = nonJokers[0].number;
                        const mimicData = await showJokerTransformModal(recommendedNumber);
                        joker.mimics = mimicData;
                    } catch (e) {
                        selectedCards = selectedCards.filter(c => c.uid !== joker.uid);
                    }
                }
            }
            
            const roomData = (await getDoc(doc(db, 'rooms', currentRoomId))).data();
            const me = roomData.players.find(p => p.id === currentPlayer.id);
            renderMyHand(me, roomData);
        }

        // --- Helper Functions ---
        function generatePlayerId() { return Math.random().toString(36).substring(2, 10); }
        function generateRoomId() { return Math.random().toString(36).substring(2, 7).toUpperCase(); }
        
        function getCardStrength(card) {
            if (card.suit === 'joker' && !card.mimics) return 99;
            const cardToEval = card.mimics ? card.mimics : card;
            let value = cardToEval.number === 1 ? 14 : (cardToEval.number === 2 ? 15 : cardToEval.number);
            return value;
        }
        
        function getCardValue(card, roomData) {
            const strengthReversed = roomData.isRevolution ^ roomData.isJBackActive; // XOR
            const baseStrength = getCardStrength(card);
            if (card.suit === 'joker' && !card.mimics) return strengthReversed ? 0 : 99; // Pure Joker
            return strengthReversed ? 16 - baseStrength : baseStrength;
        }
        
        function getNextPlayerId(players, currentId, direction, skipCount) {
            const activePlayers = players.filter(p => p.rank === null).sort((a,b) => a.order - b.order);
            if (activePlayers.length === 0) return null;
            if (activePlayers.length === 1) return activePlayers[0].id;
            
            let currentIndex = activePlayers.findIndex(p => p.id === currentId);
            if (currentIndex === -1) { 
                const originalPlayer = players.find(p => p.id === currentId) || { order: -1 };
                const nextOrderedPlayer = activePlayers.find(p => p.order > originalPlayer.order);
                currentIndex = nextOrderedPlayer ? activePlayers.indexOf(nextOrderedPlayer) -1 : activePlayers.length -1;
            }
            
            const totalMoves = 1 + skipCount;
            const nextIndex = (currentIndex + (totalMoves * direction) + activePlayers.length * totalMoves) % activePlayers.length;
            return activePlayers[nextIndex].id;
        }

        function numberToString(num) {
            const map = { 1: 'A', 2: '2', 11: 'J', 12: 'Q', 13: 'K', 15: 'Joker' };
            return map[num] || String(num);
        }

        function cleanCard(card) {
            return { suit: card.suit, number: card.number, uid: card.uid };
        }
        
        function cardsToString(cards) {
            if (cards.length === 0) return "";
            const suitSymbols = { spade: '♠', heart: '♥', diamond: '♦', club: '♣' };
            return cards.map(c => {
                const cardToDisplay = c.mimics ? c.mimics : c;
                let cardStr = '';
                if (cardToDisplay.suit === 'joker') {
                    cardStr = 'Joker';
                } else {
                    cardStr = `${suitSymbols[cardToDisplay.suit]}${numberToString(cardToDisplay.number)}`;
                }
                if (c.mimics) {
                    return `Joker->[${cardStr}]`;
                }
                return cardStr;
            }).join(', ');
        }


        function createCardElement(card) {
            const el = document.createElement('div');
            el.className = 'card';
            const suitSymbols = { spade: '♠', heart: '♥', diamond: '♦', club: '♣' };
            
            if (card.suit === 'joker' && !card.mimics) {
                el.classList.add('joker');
                el.innerHTML = `<span class="suit"></span><span class="card-number">JOKER</span><span class="suit"></span>`;
            } else {
                const displayCard = card.mimics ? card.mimics : card;
                const suit = suitSymbols[displayCard.suit];
                const number = numberToString(displayCard.number);
                if (displayCard.suit === 'heart' || displayCard.suit === 'diamond') el.classList.add('red');
                el.innerHTML = `<span class="suit">${suit}</span><span class="card-number">${number}</span><span class="suit">${suit}</span>`;
            }
            if (card.mimics) el.classList.add('is-transformed');
            return el;
        }
        
        function isStair(cards) {
            if (cards.length < 3) return false;
            const cardsToEval = cards.map(c => c.mimics ? { ...c.mimics, uid: c.uid } : c);
            const realCards = cardsToEval.filter(c => c.suit !== 'joker');
            if (realCards.length === 0) return false;

            const suit = realCards[0].suit;
            if (!realCards.every(c => c.suit === suit)) return false;

            const strengths = realCards.map(c => getCardStrength(c)).sort((a,b) => a-b);
            
            // 重複チェック
            for (let i = 0; i < strengths.length - 1; i++) {
                if (strengths[i] === strengths[i+1]) return false;
            }

            let jokersAvailable = cards.length - realCards.length;
            
            for(let i = 0; i < strengths.length - 1; i++) {
                const diff = strengths[i+1] - strengths[i] - 1;
                if (diff < 0) {
                    // 通常ありえないが、ソートされているので重複と同じ
                    return false;
                }
                if (diff > 0) {
                    jokersAvailable -= diff;
                }
            }
            
            return jokersAvailable >= 0;
        }
        
        function isValidPlay(playCards, myHand, roomData) {
            if (roomData.field.length === 0 && roomData.lastPlayed.player === null &&
                myHand.some(c => c.suit === 'diamond' && c.number === 3)) {
                if (!playCards.some(c => c.suit === 'diamond' && c.number === 3)) {
                    return { valid: false, message: 'ゲームの最初はダイヤの3を含めて出す必要があります。' };
                }
            }
            
            const isOnly2s = playCards.every(c => (c.number === 2 && c.suit !== 'joker') || (c.suit === 'joker' && c.mimics && c.mimics.number === 2));
            if (new Set(playCards.map(c => c.uid)).size === myHand.length && isOnly2s) {
                 return { valid: false, message: '2 (または2に擬態したJoker) のみで上がることはできません。' };
            }
            const jokers = playCards.filter(c => c.suit === 'joker');
            const others = playCards.filter(c => c.suit !== 'joker');

            if (jokers.length > 0 && others.length > 0) {
                if (jokers.some(j => !j.mimics)) {
                    return { valid: false, message: '他のカードと出す場合、Jokerは必ず何かに擬態させてください。' };
                }
            } 
            else if (jokers.length > 0 && others.length === 0) {
                if (jokers.some(j => j.mimics)) {
                    return { valid: false, message: 'Jokerのみで出す場合は擬態できません。' };
                }
            }

            const cardsToEval = playCards.map(c => c.mimics ? { ...c.mimics, uid: c.uid } : c);
            const isPlayStair = isStair(cardsToEval);
            
            if (!isPlayStair) {
                const realCards = cardsToEval.filter(c => c.suit !== 'joker');
                const playedNumber = realCards.length > 0 ? realCards[0].number : (cardsToEval.length > 0 ? cardsToEval[0].number : null);
                if (!cardsToEval.every(c => c.number === playedNumber)) {
                    return { valid: false, message: '同じ数字のカードか、階段で出してください。' };
                }
            }
            
            if (roomData.field.length === 0) return { valid: true };

            if (playCards.length === 1 && playCards[0].suit === 'spade' && playCards[0].number === 3 &&
                roomData.field.length === 1 && roomData.field[0].suit === 'joker' && !roomData.field[0].mimics) {
                return { valid: true };
            }
            
            const isFieldStair = isStair(roomData.field);
            if(isPlayStair !== isFieldStair) return { valid: false, message: '場と同じ種類（通常 or 階段）で出してください。' };
            if (playCards.length !== roomData.field.length) return { valid: false, message: '場と同じ枚数のカードを出してください。' };
            
            let playValue, fieldValue;
            if (isPlayStair) {
                const playBaseCard = playCards.sort((a, b) => getCardStrength(a) - getCardStrength(b))[0];
                const fieldBaseCard = roomData.field.sort((a, b) => getCardStrength(a) - getCardStrength(b))[0];
                playValue = getCardValue(playBaseCard, roomData);
                fieldValue = getCardValue(fieldBaseCard, roomData);
            } else {
                playValue = getCardValue(playCards[0], roomData);
                fieldValue = getCardValue(roomData.field[0], roomData);
            }

            if (playValue <= fieldValue) return { valid: false, message: '場に出ているカードより強いカードを出してください。' };
            
            return { valid: true };
        }
        
        // --- Modal and Follow-up Actions ---
        function handlePendingAction(roomData) {
            const action = roomData.pendingActions && roomData.pendingActions[0];
            if (!action || action.actorId !== currentPlayer.id || modalOverlay.classList.contains('visible-modal')) {
                if ((!roomData.pendingActions || roomData.pendingActions.length === 0) && !modalOverlay.classList.contains('hidden')) closeModal();
                return;
            }
            const me = roomData.players.find(p => p.id === currentPlayer.id);
            const targetablePlayers = roomData.players.filter(p => p.id !== me.id && p.rank === null);
            switch(action.type) {
                // ★修正(4): 効果発動を強制にするため、キャンセルできないモーダルに変更
                case 'pass_select_player':
                    if (action.count > 1) {
                        const maxPassable = Math.min(action.count, me.hand.length);
                        if (maxPassable > 0) {
                            showPassDistributionModal('カードを渡す相手と枚数を指定してください', targetablePlayers, maxPassable, me.hand)
                                .then(distribution => {
                                    if (distribution.length > 0) {
                                        let newActions = [...roomData.pendingActions];
                                        newActions[0] = { ...action, type: 'pass_select_cards_distributed', distribution: distribution };
                                        updateDoc(doc(db, 'rooms', currentRoomId), { pendingActions: newActions });
                                    } else {
                                        clearPendingActions(); 
                                    }
                                });
                        } else {
                             clearPendingActions();
                        }
                    } else {
                        showPlayerSelectionModal('カードを渡す相手を選んでください', targetablePlayers, action.count)
                            .then(targetId => {
                                let newActions = [...roomData.pendingActions];
                                newActions[0] = { ...action, type: 'pass_select_cards', targetId: targetId };
                                updateDoc(doc(db, 'rooms', currentRoomId), { pendingActions: newActions });
                            });
                    }
                    break;
                case 'pass_select_cards':
                    showCardSelectionModal('渡すカードを選んでください', me.hand, action.count, true, false)
                        .then(cardsToGive => executeGiveCards(action.targetId, cardsToGive));
break;
                case 'pass_select_cards_distributed':
                    handleDistributedCardSelection(action.distribution, me.hand)
                        .then(allAssignments => executeGiveCardsDistributed(allAssignments));
                    break;
                case 'discard_select_cards':
                    showCardSelectionModal('捨てるカードを選んでください', me.hand, action.count, true, false)
                        .then(cardsToDiscard => executeDiscardCards(cardsToDiscard));
                    break;
               case 'bomber_select_rank':
                     showRankSelectionModal('破壊する数字を選んでください', action.count, me.hand)
                        .then(ranks => executeBomber(ranks));
                    break;
                case 'collect_select_cards':
                    showCardSelectionModal('回収するカードを選んでください', roomData.discardPile.map(c => cleanCard(c)), action.count, true, false, me.hand)
                        .then(cardsToCollect => executeCollectCards(cardsToCollect));
                    break;
               case 'steal_select_player':
                    const validTargets = targetablePlayers.filter(p => p.hand.length > 0);
                    if (action.count > 1 && validTargets.length > 0) {
                        showStealDistributionModal('カードを奪う相手と枚数を指定してください', validTargets, action.count)
                            .then(distribution => {
                                if (distribution.length > 0) 
                                {
                                    executeDistributedSteal(distribution);
                                } else {
                              
                                     clearPendingActions();
                                }
                            });
                    } else if (validTargets.length > 0) {
                         showPlayerSelectionModal('カードを奪う相手を選んでください', validTargets, action.count)
                            .then(targetId => executeStealCard(targetId, action.count))
                            .catch(() => clearPendingActions());
                    } else {
                        showModal("対象不在", "カードを奪える相手がいません。", {showConfirm: true, confirmText: "OK", showCancel: false})
                            .then(() => { closeModal(); clearPendingActions(); });
                    }
                    break;
                case 'eight_cut':
                    executeEightCut();
                    break;

            }
        }

        
        async function clearPendingActions() {
            if (currentRoomId) {
                await updateDoc(doc(db, 'rooms', currentRoomId), { pendingActions: [] });
            }
        }

       function showModal(title, bodyHtml, { confirmText = '決定', cancelText = 'キャンセル', showConfirm = true, showCancel = true, myHand = null } = {}) {
            modalTitle.textContent = title;
            modalBody.innerHTML = '';
            if (typeof bodyHtml === 'string') modalBody.innerHTML = bodyHtml;
            else modalBody.appendChild(bodyHtml);
            
            if (myHand) {
                const handToggleButton = document.createElement('button');
                handToggleButton.textContent = '自分の手札を表示';
                handToggleButton.style.marginTop = '15px';
                handToggleButton.style.backgroundColor = '#6c757d';

                const handDisplayContainer = document.createElement('div');
                handDisplayContainer.className = 'card-container';
                handDisplayContainer.style.display = 'none';
                handDisplayContainer.style.marginTop = '10px';
                handDisplayContainer.style.padding = '10px';
                handDisplayContainer.style.border = '1px solid #ccc';
                handDisplayContainer.style.borderRadius = '5px';

                myHand.forEach(card => handDisplayContainer.appendChild(createCardElement(card)));

                handToggleButton.onclick = () => {
                    const isVisible = handDisplayContainer.style.display !== 'none';
                    handDisplayContainer.style.display = isVisible ? 'none' : 'flex';
                    handToggleButton.textContent = isVisible ? '自分の手札を表示' : '手札を隠す';
                };
                
                const wrapper = document.createElement('div');
                wrapper.appendChild(handToggleButton);
                wrapper.appendChild(handDisplayContainer);
                modalBody.appendChild(wrapper);
            }
            
            modalConfirmButton.textContent = confirmText;
            modalCancelButton.textContent = cancelText;
            modalConfirmButton.style.display = showConfirm ? 'inline-block' : 'none';
            modalCancelButton.style.display = showCancel ? 'inline-block' : 'none';
            modalOverlay.classList.remove('hidden');
            modalOverlay.classList.add('visible-modal');

            return new Promise((resolve, reject) => {
                if (currentModal.reject) currentModal.reject('New modal opened');
                currentModal = { resolve, reject };

                const onConfirm = () => {
                    cleanup();
                    resolve();
                };
                const onCancel = () => {
                    cleanup();
                    reject('User cancelled');
                };
                const cleanup = () => {
                    modalConfirmButton.onclick = null;
                    modalCancelButton.onclick = null;
                    currentModal = {};
                };

                modalConfirmButton.onclick = onConfirm;
                modalCancelButton.onclick = onCancel;
            });
        }
        
        function closeModal() {
            if (currentModal.reject) currentModal.reject('Modal closed externally');
            modalOverlay.classList.add('hidden');
            modalOverlay.classList.remove('visible-modal');
            currentModal = {};
        }

        async function showPlayerSelectionModal(title, players, count) {
            return new Promise((resolve, reject) => {
                const container = document.createElement('div');
                container.className = 'modal-player-selection';
                 if (players.length === 0) {
                    container.textContent = "対象となるプレイヤーがいません。効果は不発に終わります。";
                    setTimeout(() => { closeModal(); reject(); clearPendingAction(); }, 2000);
                 }
                players.forEach(p => {
                    const btn = document.createElement('button');
                    btn.textContent = p.name;
                    btn.onclick = () => { closeModal(); resolve(p.id); };
                    container.appendChild(btn);
                });
                // ★修正(4): キャンセルボタンを非表示に
                showModal(title, container, { showConfirm: false, showCancel: false });
            });
        }
        
       async function showCardSelectionModal(title, availableCards, count, mustSelectAll, allowCancel = true, myHand = null) {
             return new Promise((resolve, reject) => {
                const container = document.createElement('div');
                container.className = 'card-container modal-card-selection';
                let selectedModalCards = [];
                availableCards.forEach(card => {
                    const cardEl = createCardElement(card);
                    cardEl.onclick = () => {
                        const isSelected = selectedModalCards.some(c => c.uid === card.uid);
                        if (isSelected) {
                            selectedModalCards = selectedModalCards.filter(c => c.uid !== card.uid);
                            cardEl.classList.remove('selected');
                        } else if (selectedModalCards.length < count) {
                            selectedModalCards.push(card);
                            cardEl.classList.add('selected');
                        }
                        updateButtonState();
                    };
                    container.appendChild(cardEl);
                });
                const updateButtonState = () => {
                    const requiredCount = mustSelectAll ? Math.min(count, availableCards.length) : count;
                    modalConfirmButton.disabled = selectedModalCards.length !== requiredCount;
                };
                showModal(title, container, { showCancel: allowCancel, myHand: myHand }).then(() => { closeModal(); resolve(selectedModalCards); }).catch(() => { if(allowCancel) { closeModal(); reject(); } });
                updateButtonState();
            });
        }

       async function showRankSelectionModal(title, count, myHand) {
             return new Promise((resolve, reject) => {
                const ranks = [3,4,5,6,7,8,9,10,11,12,13,1,2,15];
                const container = document.createElement('div');
                container.className = 'modal-rank-selection';
                let selectedRanks = [];

                ranks.forEach(rank => {
                    const btn = document.createElement('button');
                    btn.textContent = numberToString(rank);
                    btn.onclick = () => {
                        if (selectedRanks.includes(rank)) {
                            selectedRanks = selectedRanks.filter(r => r !== rank);
                            btn.classList.remove('selected');
                        } else if (selectedRanks.length < count) {
                            selectedRanks.push(rank);
                            btn.classList.add('selected');
                        }
                        modalConfirmButton.disabled = selectedRanks.length !== count;
                    };
                    container.appendChild(btn);
                });
                
                showModal(`${title} (${count}種類選択)`, container, { showCancel: false, myHand: myHand })
                    .then(() => { closeModal(); resolve(selectedRanks); });
                modalConfirmButton.disabled = true;
            });
        }
        
        // ★修正(7): Joker擬態モーダルを全面的に修正
        async function showJokerTransformModal(recommendedNumber = null) {
            return new Promise((resolve, reject) => {
                const container = document.createElement('div');
                container.className = 'modal-joker-transform';
                
                // --- Recommended Section ---
                if (recommendedNumber) {
                    const p = document.createElement('p');
                    p.innerHTML = `<b>おすすめ:</b> 「${numberToString(recommendedNumber)}」に擬態 (スートを選択)`;
                    container.appendChild(p);
                    const recommendedContainer = document.createElement('div');
                    ['spade', 'heart', 'diamond', 'club'].forEach(suit => {
                        const btn = document.createElement('button');
                        const cardEl = createCardElement({ suit, number: recommendedNumber });
                        btn.style.width = '80px';
                        btn.style.height = '110px';
                        btn.appendChild(cardEl);
                        btn.onclick = () => { closeModal(); resolve({ suit, number: recommendedNumber }); };
                        recommendedContainer.appendChild(btn);
                    });
                    container.appendChild(recommendedContainer);
                    container.appendChild(document.createElement('hr'));
                }

                // --- Manual Section ---
                const p2 = document.createElement('p');
                p2.innerHTML = '<b>手動設定:</b> 好きなカードに擬態';
                container.appendChild(p2);
                
                const manualContainer = document.createElement('div');
                const ranks = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1, 2];
                let selectedRankEl = null, selectedSuitEl = null;
                let selectedRank = null, selectedSuit = null;
                
                const rankDiv = document.createElement('div');
                rankDiv.style.marginBottom = '10px';
                const pRank = document.createElement('p');
                pRank.textContent = '1. 数字を選択';
                rankDiv.appendChild(pRank);
                ranks.forEach(r => {
                    const btn = document.createElement('button');
                    btn.textContent = numberToString(r);
                    btn.onclick = () => {
                        if (selectedRankEl) selectedRankEl.classList.remove('selected');
                        selectedRank = r;
                        selectedRankEl = btn;
                        btn.classList.add('selected');
                        checkManualSelection();
                    };
                    rankDiv.appendChild(btn);
                });
                manualContainer.appendChild(rankDiv);

                const suitDiv = document.createElement('div');
                const pSuit = document.createElement('p');
                pSuit.textContent = '2. スートを選択';
                suitDiv.appendChild(pSuit);
                ['spade', 'heart', 'diamond', 'club'].forEach(s => {
                    const btn = document.createElement('button');
                    btn.textContent = { spade: '♠', heart: '♥', diamond: '♦', club: '♣' }[s];
                    btn.style.fontSize = '24px';
                    btn.onclick = () => {
                        if (selectedSuitEl) selectedSuitEl.classList.remove('selected');
                        selectedSuit = s;
                        selectedSuitEl = btn;
                        btn.classList.add('selected');
                        checkManualSelection();
                    };
                    suitDiv.appendChild(btn);
                });
                manualContainer.appendChild(suitDiv);
                container.appendChild(manualContainer);

                const checkManualSelection = () => {
                    modalConfirmButton.disabled = !(selectedRank && selectedSuit);
                };

                showModal('Joker擬態', container, { showConfirm: true, confirmText: '手動設定で決定', showCancel: true, cancelText: 'やめる' })
                    .then(() => {
                        if (selectedRank && selectedSuit) {
                            resolve({ suit: selectedSuit, number: selectedRank });
                        } else {
                            reject('No manual selection made');
                        }
                    })
                    .catch(() => reject('User cancelled'))
                    .finally(closeModal);
                
                checkManualSelection();
            });
        }
        
        function showResultsModal(players) {
            const sortedPlayers = [...players].sort((a,b) => {
                if (a.rank === null) return 1;
                if (b.rank === null) return -1;
                return a.rank - b.rank;
            });

            let tableHtml = `<table id="results-table"><thead><tr><th>順位</th><th>名前</th></tr></thead><tbody>`;
            sortedPlayers.forEach(p => {
                const rankDisplay = p.rank ? `${p.rank}位` : '最下位';
                tableHtml += `<tr><td>${rankDisplay}</td><td>${p.name}</td></tr>`;
            });
            tableHtml += `</tbody></table>`;
            
            showModal('ゲーム結果', tableHtml, { confirmText: 'ルームに戻る', showCancel: false })
              .then(() => {
                  closeModal();
              })
              .catch(() => {});
        }


        // --- Game Logic Helpers ---
        function handlePlayerFinish(players, finishedPlayerId) {
            const finishedCount = players.filter(p => p.rank !== null).length;
            const newRank = finishedCount + 1;
            const logs = [];
            const updatedPlayers = players.map(p => {
                if (p.id === finishedPlayerId && p.rank === null) {
                    const message = `${p.name}が${newRank}位で上がりました！`;
                    logs.push({ timestamp: Date.now(), message: message });
                    showCutIn(p.name, `${newRank}位でゴール！`);
                    return { ...p, rank: newRank };
                }
                return p;
            });
            return { updatedPlayers, 上がりLog: logs };
        }

        
        function checkGameEnd(state) {
            const activePlayers = state.players.filter(p => p.rank === null);
            if (activePlayers.length <= 1) {
                state.gameState = 'finished';
                if (activePlayers.length === 1) {
                    const lastPlayer = activePlayers[0];
                    const rankCount = state.players.filter(p => p.rank !== null).length;
                    state.players = state.players.map(p => p.id === lastPlayer.id ? {...p, rank: rankCount + 1} : p);
                }
            }
            return state;
        }


        // --- Action Execution Functions ---
                async function executeAction(actionFn, logMessageFn, logContext) {
            const roomRef = doc(db, 'rooms', currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room not found");
                    let roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);
                    
                    let { players, discardPile, logContext: actionLogContext } = await actionFn(roomData, me);
                    const finalLogContext = logContext || actionLogContext || {};
                    const logMessage = logMessageFn(finalLogContext);
    
                    let logEntry = {timestamp: Date.now(), message: logMessage};
                    if (finalLogContext.effect) {
                        logEntry.effect = finalLogContext.effect;
                    }
                    let logEntries = [logEntry];
                    
                    let tempPlayers = players;

                    // アクションの結果、手札が0枚になった全プレイヤーをチェックする
                    const originalPlayers = roomData.players;
                    tempPlayers.forEach(p => {
                        const originalPlayer = originalPlayers.find(op => op.id === p.id);
                        if (p.hand.length === 0 && originalPlayer && originalPlayer.hand.length > 0 && p.rank === null) {
                            const { updatedPlayers, 上がりLog } = handlePlayerFinish(tempPlayers, p.id);
                            tempPlayers = updatedPlayers;
                            logEntries.push(...上がりLog);
                        }
                    });
                    players = tempPlayers;
                    
                    const newPendingActions = roomData.pendingActions ? roomData.pendingActions.slice(1) : [];
                    
                    let nextState = {
                        players: players,
                        discardPile: discardPile || roomData.discardPile,
                        pendingActions: newPendingActions,
                        turnPlayerId: roomData.turnPlayerId
                    };
                    
                    if (newPendingActions.length === 0) {
                        nextState.turnPlayerId = getNextPlayerId(players, me.id, roomData.turnDirection, 0);
                    }
                    
                    const finalState = checkGameEnd(nextState);
                    transaction.update(doc(db, 'rooms', currentRoomId), {...finalState, log: arrayUnion(...logEntries)});
                });
            } catch (e) {
                showAlert(`エラー: ${e.message}`);
                await clearPendingActions();
            }
        }
        
        function executeGiveCards(targetId, cardsToGive) {
            executeAction(
                (roomData, me) => {
                    const giveUids = new Set(cardsToGive.map(c => c.uid));
                    const newMyHand = me.hand.filter(c => !giveUids.has(c.uid));
                    const targetPlayer = roomData.players.find(p => p.id === targetId);
                    const players = roomData.players.map(p => {
                        if (p.id === me.id) return { ...p, hand: newMyHand };
                        if (p.id === targetId) {
                                                        return {
                                ...p,
                                hand: [...p.hand, ...cardsToGive].sort((a,b) => getCardStrength(a) - getCardStrength(b)),
                                privateEvent: { id: Date.now(), type: 'receive_cards', actor: me.name, cards: cardsToGive }
                            };
                        }
                        return p;
                    });
                    return { players, logContext: { target: targetPlayer.name, cards: cardsToGive } };
                },

                (ctx) => `${currentPlayer.name}が${ctx.target}にカードを${ctx.cards.length}枚渡しました。`
            );
            }

        async function handleDistributedCardSelection(distribution, availableHand) {
            let allAssignments = [];
            let currentHand = [...availableHand];
            let roomData = null;
            try {
                roomData = (await getDoc(doc(db, 'rooms', currentRoomId))).data();
            } catch (e) {
                 showAlert('ルーム情報の取得に失敗しました。');
                 clearPendingActions();
                 return Promise.reject("Room data fetch failed");
            }
            if (!roomData) {
                clearPendingActions();
                return Promise.reject("Room not found");
            }

            for (const assignment of distribution) {
                try {
                    const targetPlayer = roomData.players.find(p => p.id === assignment.playerId);
                    if (!targetPlayer) continue;

                    const cards = await showCardSelectionModal(
                        `${targetPlayer.name} に渡すカードを ${assignment.count} 枚選んでください`,
                        currentHand,
                        assignment.count,
                        true,
                        false
                    );
                    allAssignments.push({ playerId: assignment.playerId, name: targetPlayer.name, cards: cards });
                    const selectedCardUids = new Set(cards.map(c => c.uid));
                    currentHand = currentHand.filter(c => !selectedCardUids.has(c.uid));
                } catch (e) {
                    console.error("Card selection for distribution failed:", e);
                    showAlert("カード選択がキャンセルされたため、アクションを中断します。");
                    await clearPendingActions();
                    return Promise.reject("Card selection cancelled");
                }
            }
            return allAssignments;
        }

        function executeGiveCardsDistributed(assignments) {
            executeAction(
                (roomData, me) => {
                    let players = roomData.players.map(p => ({...p})); 
                    let allGivenCardsUids = new Set();
                    assignments.forEach(assignment => {
                        const target = players.find(p => p.id === assignment.playerId);
                        target.hand = [...target.hand, ...assignment.cards].sort((a, b) => getCardStrength(a) - getCardStrength(b));
                        target.privateEvent = { id: Date.now() + Math.random(), type: 'receive_cards', actor: me.name, cards: assignment.cards };
                        assignment.cards.forEach(c => allGivenCardsUids.add(c.uid));
                    });
                    const meInPlayers = players.find(p => p.id === me.id);
                    meInPlayers.hand = me.hand.filter(c => !allGivenCardsUids.has(c.uid));
                    return { players, logContext: { assignments } };
                },
                (ctx) => {
                    const summary = ctx.assignments.map(a => `${a.name}に${a.cards.length}枚`).join(', ');
                    return `${currentPlayer.name}がカードを渡しました (${summary})。`;
                }
            );
        }
        
        function executeDiscardCards(cardsToDiscard) {
             executeAction(
                (roomData, me) => {
                    const discardUids = new Set(cardsToDiscard.map(c => c.uid));
                    const newMyHand = me.hand.filter(c => !discardUids.has(c.uid));
                    const players = roomData.players.map(p => p.id === me.id ? { ...p, hand: newMyHand } : p);
                    return { players, discardPile: [...roomData.discardPile, ...cardsToDiscard.map(c => cleanCard(c))], logContext: { cards: cardsToDiscard } };
                },
                (ctx) => `${currentPlayer.name}がカード(${cardsToString(ctx.cards)})を捨てました。`
            );
        }
        
        function executeBomber(ranks) {
            executeAction(
                (roomData, me) => {
                    const rankSet = new Set(ranks);
                    let allDiscarded = [];
                    let finishedPlayerIds = [];

                    const players = roomData.players.map(p => {
                        if (p.rank !== null) return p;
                        const discarded = p.hand.filter(c => rankSet.has(c.number) || (rankSet.has(15) && c.suit === 'joker'));
                        const newHand = p.hand.filter(c => !discarded.find(dc => dc.uid === c.uid));
                        if(discarded.length > 0) allDiscarded.push(...discarded);
                        if(newHand.length === 0 && p.hand.length > 0) finishedPlayerIds.push(p.id);
                        return { ...p, hand: newHand };
                    });

                    if (finishedPlayerIds.length > 0) {
                        const finishedCount = roomData.players.filter(p => p.rank !== null).length;
                        const newRank = finishedCount + 1;
                        finishedPlayerIds.forEach(id => {
                            const pIndex = players.findIndex(p => p.id === id);
                            players[pIndex].rank = newRank;
                        });
                    }

                    return { players, discardPile: [...roomData.discardPile, ...allDiscarded.map(c => cleanCard(c))], logContext: { ranks } };
                },
                                (ctx) => `${currentPlayer.name}が数字[${ctx.ranks.map(numberToString).join(',')}]を破壊しました。`,
                {
                    ranks,
                    effect: {
                        card: `数字[${ranks.map(numberToString).join(',')}]`,
                        name: 'Qボンバー'
                    }
                }
            );
        }



        function executeCollectCards(cardsToCollect) {
            executeAction(
                (roomData, me) => {
                    const collectUids = new Set(cardsToCollect.map(c => c.uid));
                    const newMyHand = [...me.hand, ...cardsToCollect].sort((a,b) => getCardStrength(a)-getCardStrength(b));
       
                     const players = roomData.players.map(p => p.id === me.id ? { ...p, hand: newMyHand } : p);
                    return {
                        players,
                        discardPile: roomData.discardPile.filter(c => !collectUids.has(c.uid)),
                        logContext: {
                            cards: cardsToCollect,
                            effect: {
                                card: me.name,
                                name: `${cardsToString(cardsToCollect)}を回収`
                            }
                        }
                    };
                },
                (ctx) => `${currentPlayer.name}が捨て札からカード(${cardsToString(ctx.cards)})を回収しました。`
      
             );
        }

        
        function executeStealCard(targetId, count) {
            executeAction(
                (roomData, me) => {
                    let target = roomData.players.find(p => p.id === targetId);
                    if (!target || target.hand.length === 0) throw new Error("対象にカードがありません。");
                    let targetHand = [...target.hand];
                    let stolenCards = [];
                    for(let i=0; i<count && targetHand.length > 0; i++) {
                        stolenCards.push(targetHand.splice(Math.floor(Math.random() * targetHand.length), 1)[0]);
                    }
                    const newMyHand = [...me.hand, ...stolenCards].sort((a,b) => getCardStrength(a)-getCardStrength(b));
                    const players = roomData.players.map(p => {
                                if (p.id === me.id) return { ...p, hand: newMyHand, privateEvent: { id: Date.now(), type: 'steal_success', target: target.name, cards: stolenCards } };
                        if (p.id === targetId) return { ...p, hand: targetHand, privateEvent: { id: Date.now() + 1, type: 'stolen', actor: me.name, cards: stolenCards } };
return p;
                    });
                    return { players, logContext: { target: target.name, count: count } };

                },
                (ctx) => `${currentPlayer.name}が${ctx.target}からカードを${ctx.count}枚奪いました。`
);

        }
                function executeDistributedSteal(distribution) {
            executeAction(
                (roomData, me) => {
                    let players = [...roomData.players];
                    let logDetails = [];
                    let allStolenCardsForMe = [];

                    distribution.forEach(({playerId, count}) => {
                        if (count <= 0) return;
                        
                        let target = players.find(p => p.id === playerId);
                        if (!target || target.hand.length < count) {
                            throw new Error(`${target.name}から指定された枚数を奪えません。`);
                        }
                        
                        let targetHand = [...target.hand];
                        let stolenCards = [];
                        for(let i=0; i < count && targetHand.length > 0; i++) {
                            stolenCards.push(targetHand.splice(Math.floor(Math.random() * targetHand.length), 1)[0]);
                        }
                        
                        allStolenCardsForMe.push(...stolenCards);
                        logDetails.push({ name: target.name, count });

                        const targetIndex = players.findIndex(p => p.id === playerId);
                        players[targetIndex] = {
                            ...players[targetIndex],
                            hand: targetHand,
                            privateEvent: { id: Date.now() + Math.random(), type: 'stolen', actor: me.name, cards: stolenCards }
                        };
                    });

                    const myIndex = players.findIndex(p => p.id === me.id);
                    const newMyHand = [...me.hand, ...allStolenCardsForMe].sort((a,b) => getCardStrength(a)-getCardStrength(b));
                    players[myIndex] = {
                        ...players[myIndex],
                        hand: newMyHand,
                        privateEvent: { id: Date.now(), type: 'steal_success', target: '複数人', cards: allStolenCardsForMe }
                    };

                    return { players, logContext: { logDetails } };
                },
                (ctx) => {
                    const stealSummary = ctx.logDetails.map(d => `${d.name}から${d.count}枚`).join(', ');
                    return `${currentPlayer.name}が${stealSummary}奪いました。`;
                }
            );
        }

        async function showStealDistributionModal(title, targetablePlayers, totalCount) {
            return new Promise((resolve, reject) => {
                const maxPossibleSteal = Math.min(totalCount, targetablePlayers.reduce((sum, p) => sum + p.hand.length, 0));
                
                const container = document.createElement('div');
                let assignments = {};
                targetablePlayers.forEach(p => assignments[p.id] = 0);

                const header = document.createElement('p');
                header.innerHTML = `合計 <b>${maxPossibleSteal}</b> 枚を下のプレイヤーに割り振ってください。`;
                container.appendChild(header);
                
                const remainingDiv = document.createElement('div');
                remainingDiv.style.fontWeight = 'bold';
                remainingDiv.style.marginBottom = '15px';
                container.appendChild(remainingDiv);

                const updateTotal = () => {
                    const totalAssigned = Object.values(assignments).reduce((sum, val) => sum + val, 0);
                    remainingDiv.textContent = `残り: ${maxPossibleSteal - totalAssigned}`;
                    modalConfirmButton.disabled = totalAssigned !== maxPossibleSteal;
                };

                targetablePlayers.forEach(p => {
                    const playerDiv = document.createElement('div');
                    playerDiv.style.display = 'flex';
                    playerDiv.style.justifyContent = 'space-between';
                    playerDiv.style.alignItems = 'center';
                    playerDiv.style.margin = '8px 0';

                    const nameLabel = document.createElement('span');
                    nameLabel.textContent = `${p.name} (手札: ${p.hand.length}枚)`;
                    
                    const controlsDiv = document.createElement('div');
                    const minusBtn = document.createElement('button');
                    minusBtn.textContent = '-';
                    minusBtn.style.width = '30px';
                    
                    const countSpan = document.createElement('span');
                    countSpan.textContent = '0';
                    countSpan.style.margin = '0 10px';
                    countSpan.style.display = 'inline-block';
                    countSpan.style.width = '20px';
                    
                    const plusBtn = document.createElement('button');
                    plusBtn.textContent = '+';
                    plusBtn.style.width = '30px';

                    minusBtn.onclick = () => {
                        if (assignments[p.id] > 0) {
                            assignments[p.id]--;
                            countSpan.textContent = assignments[p.id];
                            updateTotal();
                        }
                    };
                    plusBtn.onclick = () => {
                        const totalAssigned = Object.values(assignments).reduce((sum, val) => sum + val, 0);
                        if (totalAssigned < maxPossibleSteal && assignments[p.id] < p.hand.length) {
                            assignments[p.id]++;
                            countSpan.textContent = assignments[p.id];
                            updateTotal();
                        }
                    };

                    controlsDiv.appendChild(minusBtn);
                    controlsDiv.appendChild(countSpan);
                    controlsDiv.appendChild(plusBtn);
                    playerDiv.appendChild(nameLabel);
                    playerDiv.appendChild(controlsDiv);
                    container.appendChild(playerDiv);
                });

                showModal(title, container, { showConfirm: true, showCancel: false })
                    .then(() => {
                        const distribution = Object.entries(assignments)
                            .map(([playerId, count]) => ({ playerId, count }))
                            .filter(item => item.count > 0);
                        resolve(distribution);
                    })
                    .catch(reject);
                
                updateTotal();
            });
        }
        
        async function showPassDistributionModal(title, targetablePlayers, totalCount, myHand) {
            return new Promise((resolve, reject) => {
                if (targetablePlayers.length === 0) {
                    showModal("対象不在", "カードを渡せる相手がいません。", {showConfirm: true, confirmText: "OK", showCancel: false})
                        .then(() => { closeModal(); resolve([]); });
                    return;
                }

                const container = document.createElement('div');
                let assignments = {};
                targetablePlayers.forEach(p => assignments[p.id] = 0);

                const header = document.createElement('p');
                header.innerHTML = `合計 <b>${totalCount}</b> 枚を下のプレイヤーに割り振ってください。`;
                container.appendChild(header);

                const remainingDiv = document.createElement('div');
                remainingDiv.style.fontWeight = 'bold';
                remainingDiv.style.marginBottom = '15px';
                container.appendChild(remainingDiv);

                const updateTotal = () => {
                    const totalAssigned = Object.values(assignments).reduce((sum, val) => sum + val, 0);
                    remainingDiv.textContent = `残り: ${totalCount - totalAssigned}`;
                    modalConfirmButton.disabled = totalAssigned !== totalCount;
                };

                targetablePlayers.forEach(p => {
                    const playerDiv = document.createElement('div');
                    playerDiv.style.display = 'flex';
                    playerDiv.style.justifyContent = 'space-between';
                    playerDiv.style.alignItems = 'center';
                    playerDiv.style.margin = '8px 0';

                    const nameLabel = document.createElement('span');
                    nameLabel.textContent = `${p.name}`;

                    const controlsDiv = document.createElement('div');
                    const minusBtn = document.createElement('button');
                    minusBtn.textContent = '-';
                    minusBtn.style.width = '30px';

                    const countSpan = document.createElement('span');
                    countSpan.textContent = '0';
                    countSpan.style.margin = '0 10px';
                    countSpan.style.display = 'inline-block';
                    countSpan.style.width = '20px';

                    const plusBtn = document.createElement('button');
                    plusBtn.textContent = '+';
                    plusBtn.style.width = '30px';

                    minusBtn.onclick = () => {
                        if (assignments[p.id] > 0) {
                            assignments[p.id]--;
                            countSpan.textContent = assignments[p.id];
                            updateTotal();
                        }
                    };
                    plusBtn.onclick = () => {
                        const totalAssigned = Object.values(assignments).reduce((sum, val) => sum + val, 0);
                        if (totalAssigned < totalCount) {
                            assignments[p.id]++;
                            countSpan.textContent = assignments[p.id];
                            updateTotal();
                        }
                    };
                    controlsDiv.appendChild(minusBtn);
                    controlsDiv.appendChild(countSpan);
                    controlsDiv.appendChild(plusBtn);
                    playerDiv.appendChild(nameLabel);
                    playerDiv.appendChild(controlsDiv);
                    container.appendChild(playerDiv);
                });

                showModal(title, container, { showConfirm: true, showCancel: false, myHand: myHand })
                    .then(() => {
                        const distribution = Object.entries(assignments)
                            .map(([playerId, count]) => ({ playerId, count }))
                            .filter(item => item.count > 0);
                        resolve(distribution);
                    })
                    .catch(reject);
                updateTotal();
            });
        }


                async function executeEightCut() {

            const roomRef = doc(db, 'rooms', currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("Room not found");
                    const roomData = roomSnap.data();
                    const me = roomData.players.find(p => p.id === currentPlayer.id);

                    const newDiscard = [...roomData.discardPile, ...roomData.field.map(c => cleanCard(c))];
                    const logEntry = { timestamp: Date.now(), message: `${me.name}の(階段効果)8切りにより場が流れ、リセットされます。` };
                    
                    const newPendingActions = roomData.pendingActions.slice(1);
                    
                    const nextTurnPlayerId = me.id;

                    transaction.update(roomRef, {
                        field: [],
                        passCount: 0,
                        isJBackActive: false,
                        discardPile: newDiscard,
                        pendingActions: newPendingActions,
                        turnPlayerId: nextTurnPlayerId,
                        log: arrayUnion(logEntry)
                    });
                });
            } catch (e) {
                showAlert(`8切り処理エラー: ${e.message}`);
                await clearPendingActions();
            }
        }


        // --- Log and Cut-in ---
        function renderLog(log) {
            if (log.length === lastKnownLogCount) return;

            logMessagesDiv.innerHTML = '';
            log.forEach(entry => {
                const p = document.createElement('p');
                p.textContent = entry.message;
                logMessagesDiv.prepend(p);

                // Cut-in trigger
                if (log.indexOf(entry) >= lastKnownLogCount && entry.effect) {
                    showCutIn(entry.effect.card, entry.effect.name);
                }
            });
            lastKnownLogCount = log.length;
        }

        function showCutIn(cardName, effectName) {
            cutinOverlay.classList.remove('hidden');
            cutinCardName.textContent = cardName;
            cutinEffectName.textContent = effectName;
            cutinOverlay.offsetHeight; // Trigger reflow
            cutinOverlay.classList.add('visible');
            setTimeout(() => {
                cutinOverlay.classList.remove('visible');
                setTimeout(() => cutinOverlay.classList.add('hidden'), 500);
            }, 1500);
        }
        
showLogButton.addEventListener('click', () => logPanel.classList.add('visible'));
        logCloseButton.addEventListener('click', () => logPanel.classList.remove('visible'));

        // Initialize
        showScreen('login');

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>
